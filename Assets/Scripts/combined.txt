--- FOLDER STRUCTURE ---
Folder PATH listing for volume Windows
Volume serial number is 5895-C779
C:\USERS\KOMJA_5IITWGQ\DOCUMENTS\UNITYPROJECTS\UNITY GAMES\ANYWHERE\ASSETS\SCRIPTS\F
Invalid path - \USERS\KOMJA_5IITWGQ\DOCUMENTS\UNITYPROJECTS\UNITY GAMES\ANYWHERE\ASSETS\SCRIPTS\F
No subfolders exist 


--- SCRIPTS CONTENT ---
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\CraftingManager.cs
------------------------------
using UnityEngine;
public class CraftingManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\EnvironmentManager.cs
------------------------------
using UnityEngine;
public class EnvironmentManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\GameManager.cs
------------------------------
using UnityEngine;

/// <summary>
/// Bootstrap that
/// • builds WorldManager, UIManager, and WorldTilemapViewer in code
/// • wires viewer ⇄ world manager
/// </summary>
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    /* ───────── Inspector options ───────── */
    [Header("Data assets")]
    [SerializeField] GameData gameData;

    [Header("Viewer settings")]
    [SerializeField] int defaultViewRadius = 64;      // tiles

    /* ───────── Runtime refs ───────── */
   
    CraftingManager    craftingManager;
    EnvironmentManager environmentManager;
    MusicManager musicManager;
    PlayerManager playerManager;
    ProjectileManager projectileManager;
    SceneManager sceneManager;
    UIManager          uiManager;
    UnitManager unitManager;
    WorldManager       worldManager;
    WorldTilemapViewer viewer;

    /* ───────── LIFECYCLE ───────── */
    void Awake()
    {
        if (Instance != null) { Destroy(gameObject); return; }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        // Core systems
        worldManager = gameObject.AddComponent<WorldManager>();
        uiManager    = gameObject.AddComponent<UIManager>();
        viewer       = BuildViewer();
        viewer.worldManager = worldManager;
    }

    void Start()
    {
        uiManager.Initialize();
        worldManager.InitializeWorld(gameData.world);
    }

    /* ───────── PUBLIC API ───────── */
    public void AddTrackedTarget(Transform t, int radius = 0)
    {
        if (!t) return;

        int r = radius == 0 ? defaultViewRadius : radius;
        viewer.AddTarget(t, r);
    }

    /* ───────── Viewer factory ───────── */
    WorldTilemapViewer BuildViewer()
    {
        var go = new GameObject("TilemapViewer");
        go.transform.SetParent(transform);
        return go.AddComponent<WorldTilemapViewer>();  // auto-creates Grid & maps
    }

    /* ───────── Debug keys (if you still need them) ───────── */
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha0))
            gameData.world.seed = Random.Range(0, 1000);

        if (Input.GetKeyDown(KeyCode.Alpha1))
            worldManager.GenerateBiomeMap();

        if (Input.GetKeyDown(KeyCode.Alpha2))
            worldManager.GenerateWorldMap(OnWorldCreated);

        if (Input.GetKeyDown(KeyCode.Alpha3))
            worldManager.GenerateWorldPOI(OnWorldCreated);

        if (Input.GetKeyDown(KeyCode.Alpha4))
            worldManager.GenerateWorldPost(OnWorldCreated);

        if (Input.GetKeyDown(KeyCode.Alpha5))
            uiManager.DisplayAreaMap(worldManager.GetCurrentWorld(), gameData.world);

        if (Input.GetKeyDown(KeyCode.Alpha6))
            uiManager.DisplayBiomeMap(worldManager.GetCurrentWorld(), gameData.world);
    }

    void OnWorldCreated()
        => uiManager.DisplayWorldMap(worldManager.GetCurrentWorld());
}

------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\MusicManager.cs
------------------------------
using UnityEngine;
public class MusicManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\PlayerManager.cs
------------------------------
using UnityEngine;
public class PlayerManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\ProjectileManager.cs
------------------------------
using UnityEngine;
public class ProjectileManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\SceneManager.cs
------------------------------
using UnityEngine;
public class SceneManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\UIManager.cs
------------------------------
using UnityEngine;

public class UIManager : MonoBehaviour
{
    [SerializeField] MapPreviewer mapPreviewer;

    public void Initialize()
    {
        if (mapPreviewer == null)
        {
            var go = new GameObject("MapPreviewer");
            go.transform.SetParent(transform);
            mapPreviewer = go.AddComponent<MapPreviewer>();
        }
    }

    // Option A: separate methods for area vs biome
    public void DisplayAreaMap(World world, WorldData data)
    {
        if (mapPreviewer != null && world != null && data != null)
        {
            mapPreviewer.areasDatabase = data.areasDatabase; 
            mapPreviewer.RenderAreaCanvas(world);
        }
    }

    public void DisplayBiomeMap(World world, WorldData data)
    {
        if (mapPreviewer != null && world != null && data != null)
        {
            mapPreviewer.biomeDatabase = data.biomeDatabase; 
            mapPreviewer.RenderBiomeCanvas(world);
        }
    }

    // Or you might keep your existing:
    public void DisplayWorldMap(World world)
    {
        if (mapPreviewer != null && world != null)
        {
            mapPreviewer.RenderWorldCanvasBoth(world);
        }
    }
}

------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\UnitManager.cs
------------------------------
using UnityEngine;
public class UnitManager : MonoBehaviour
{
}
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Managers\WorldManager.cs
------------------------------
using UnityEngine;
using System.Collections;
using System;

public class WorldManager : MonoBehaviour
{
    bool isGeneratingWorld = false;
 
    private World currentWorld;
    private WorldData worldData;
    public World GetCurrentWorld() => currentWorld;
       public void InitializeWorld(WorldData data)
    {
        if (data == null)
        {
            Debug.LogError("WorldManager.InitializeWorld: WorldData is null!");
            return;
        }

        worldData   = data;               // keep for later inspections/saves
        currentWorld = new World(data);   // new 1-arg ctor
        currentWorld.CreateAllChunks();

        Debug.Log($"World initialized ({data.widthInChunks}×{data.heightInChunks} chunks, seed {data.seed})");
    }
    public void GenerateBiomeMap( Action onMapGenerated = null)
    {
        if (!isGeneratingWorld)
        {
            StartCoroutine(GenerateBiomeMapRoutine( onMapGenerated));
        }
        else
        {
            Debug.LogWarning("World generation already in progress. Please wait.");
        }
    }

    IEnumerator GenerateBiomeMapRoutine( Action onMapGenerated)
    {
        isGeneratingWorld = true;
        float startTime = Time.realtimeSinceStartup;

 
        yield return BiomeMapGenerator.GenerateFullMapAsync(currentWorld,worldData, map =>
        {
            currentWorld = map;
        });



        float duration = Time.realtimeSinceStartup - startTime;
        Debug.Log($"Async BIOME map generation took {duration:F2} seconds.");

        isGeneratingWorld = false;
        onMapGenerated?.Invoke();
    }

    public void GenerateWorldMap( Action onWorldCreated = null)
    {
        if (isGeneratingWorld)
        {
            Debug.LogWarning("World generation already in progress. Please wait.");
            return;
        }


        StartCoroutine(GenerateWorldMapRoutine(onWorldCreated));
    }
IEnumerator GenerateWorldMapRoutine(Action onWorldCreated)
{
    isGeneratingWorld = true;
    float startTime = Time.realtimeSinceStartup;

    // Use the existing currentWorld
    WorldMapGenerator.GenerateWorldTiles(currentWorld, worldData);

    float duration = Time.realtimeSinceStartup - startTime;
    Debug.Log($"Async WORLD generation took {duration:F2} seconds.");

    isGeneratingWorld = false;
    onWorldCreated?.Invoke();
    yield break;
}

    /// <summary>
    /// Generates (places) all Points of Interest in the current world, 
    /// by calling WorldMapPOIGenerator.PlaceAllPois.
    /// Calls onWorldCreated when done.
    /// </summary>
    public void GenerateWorldPOI(Action onWorldCreated = null)
    {
        if (currentWorld == null)
        {
            Debug.LogWarning("No current world to place POIs. Generate/Initialize the world first.");
            onWorldCreated?.Invoke();
            return;
        }

        if (isGeneratingWorld)
        {
            Debug.LogWarning("World generation or placement is already in progress. Please wait.");
            onWorldCreated?.Invoke();
            return;
        }

        StartCoroutine(GenerateWorldPOIRoutine(onWorldCreated));
    }

    private IEnumerator GenerateWorldPOIRoutine(Action onWorldCreated)
    {
        isGeneratingWorld = true;
        float startTime = Time.realtimeSinceStartup;

        // Actually place the POIs (both surface and normal)
        WorldMapPOIGenerator.PlaceAllPois(currentWorld, worldData);

        float duration = Time.realtimeSinceStartup - startTime;
        Debug.Log($"Async POI generation took {duration:F2} seconds.");

        isGeneratingWorld = false;
        onWorldCreated?.Invoke();
        yield break;
    }
    public void GenerateWorldPost(Action onWorldProcessed = null)
    {
        if (currentWorld == null)
        {
            Debug.LogWarning("No current world to post-process. Generate the world first.");
            onWorldProcessed?.Invoke();
            return;
        }

        if (isGeneratingWorld)
        {
            Debug.LogWarning("World generation or post-processing already in progress. Please wait.");
            onWorldProcessed?.Invoke();
            return;
        }

        StartCoroutine(GenerateWorldPostRoutine(onWorldProcessed));
    }

    IEnumerator GenerateWorldPostRoutine(Action onWorldProcessed)
    {
        isGeneratingWorld = true;
        float startTime = Time.realtimeSinceStartup;

        WorldMapPostGenerator.PostProcessWorld(currentWorld, worldData);

        float duration = Time.realtimeSinceStartup - startTime;
        Debug.Log($"Async WORLD post-process took {duration:F2} seconds.");

        isGeneratingWorld = false;
        onWorldProcessed?.Invoke();
        yield break;
    }




}

------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Systems\GameCamera.cs
------------------------------
using UnityEngine;

/// <summary>
/// Simple orthographic follow-camera.
/// • Call <see cref="SetTarget"/> to choose what to follow.
/// • Keeps a constant <see cref="offset"/> from the target,
///   smoothing movement with <see cref="lerpSpeed"/>.
/// </summary>
[RequireComponent(typeof(Camera))]
public sealed class GameCamera : MonoBehaviour
{
    [Header("Follow behaviour")]
    [SerializeField] float   lerpSpeed = 5f;            // higher → snappier
    [SerializeField] Vector3 offset    = new(0, 0, -10);

    Transform target;
    Vector3   velocity;

    /// <summary>Assign the transform to follow.</summary>
    public void SetTarget(Transform t) => target = t;

    void LateUpdate()
    {
        if (!target) return;

        Vector3 goal = target.position + offset;
        transform.position = Vector3.SmoothDamp(
            transform.position, goal, ref velocity, 1f / lerpSpeed);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Core\Systems\SaveLoadSystem.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\CraftingRecipeData.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\EntityData.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\GameData.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Game", menuName = "Game/System/new Game")]
public class GameData : ScriptableObject
{
    
    public WorldData world;
  
    [Header("Game Settings")]
    public GameSettings settings;

    // Add additional references to databases or settings as your project grows.
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\GameSettings.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Settings", menuName = "Game/System/new Settings")]
public class GameSettings : ScriptableObject
{


}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\ItemData.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\ProjectileData.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\UnitData.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprint.cs
------------------------------
using UnityEngine;

/// <summary>Base asset for anything that paints into a <see cref="World"/>.</summary>
public abstract class Blueprint : ScriptableObject
{
    [TextArea] public string description = "Optional notes";

    /* ───────────── public entry point ───────────── */

    public abstract void PlaceStructure(World world, int x, int y);


}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Growable\BlueprintCactus.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_Cactus_", menuName = "Game/World/Blueprint/Growable/Cactus Blueprint")]
public class BlueprintCactus : BlueprintGrowable
{
    public int cactusHeight = 3;
    public TileData cactusTile;

    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        if (cactusTile == null) return;

        // Place a vertical cactus column up to cactusHeight
        for (int i = 0; i < cactusHeight; i++)
        {
            int py = anchorY + i;
            world.SetTileID( anchorX, py, cactusTile.tileID);
        }
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Growable\BlueprintGrowable.cs
------------------------------
using UnityEngine;

public abstract class BlueprintGrowable : Blueprint
{
    [Header("Space requirements")]
    public int FreeHeightRequired = 3;   // tiles upward from anchorY
    public int FreeWidthRequired  = 1;   // tiles centred on anchorX
    public TileData[] SuitableGroundTiles;   
/// <summary>
/// Returns true only when BOTH conditions hold:
///   • The tile directly below anchorY is in SuitableGroundTiles
///     (or the list is empty, meaning “any solid block”).
///   • Every tile inside the clearance box is empty / air / tree.
/// </summary>
public bool HasFreeSpace(World world, int anchorX, int anchorY)
{
    /* ── 1 ▸ Ground-tile test ─────────────────────────────────────── */
    int groundY = anchorY - 1;
    if (groundY < 0) return false;                       // beneath world

    int groundID = world.GetTileID(anchorX, groundY);
    if (groundID == 0) return false;                     // can’t grow in mid-air

    // If a whitelist exists, groundID must match one of its entries.
    if (SuitableGroundTiles != null && SuitableGroundTiles.Length > 0)
    {
        bool ok = false;
        foreach (var td in SuitableGroundTiles)
            if (td != null && td.tileID == groundID) { ok = true; break; }
        if (!ok) return false;
    }

    /* ── 2 ▸ Clearance-box test ───────────────────────────────────── */
    int halfW = Mathf.FloorToInt(FreeWidthRequired * 0.5f);

    for (int x = anchorX - halfW; x <= anchorX + halfW; x++)
    for (int y = anchorY;        y <  anchorY + FreeHeightRequired; y++)
    {
        int id = world.GetTileID(x, y);
        if (id == 0) continue;                           // empty

        TileData td = world.tiles.GetTileDataByID(id);
        if (td == null)        return false;             // unknown tile → block
        if (td.behavior == BlockBehavior.Air) continue;  // sky/underground air
        if (td.tag      == BlockTag.Tree)      continue; // treat other trees as air

        return false;                                    // blocked by solid/liquid/etc.
    }

    return true;
}


    public abstract override void PlaceStructure(World world, int anchorX, int anchorY);
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Growable\BlueprintTree.cs
------------------------------
/* ──────────────────────────────────────────────────────────────────────────
   BlueprintTree – trunk + side leaves + distinct crown tile
   ---------------------------------------------------------------------- */
using UnityEngine;

[CreateAssetMenu(
        fileName = "Blueprint_Tree_",
        menuName  = "Game/World/Blueprint/Growable/Tree Blueprint")]
public class BlueprintTree : BlueprintGrowable
{
    /* ────────────────  Inspector fields  ──────────────── */
    [Header("Tiles")]
    [Tooltip("Bark segment (usually a RuleTile).")]
    public TileData trunkTile;        // bark

    [Tooltip("Single-leaf tile used for left / right branches.")]
    public TileData leafTile;         // branch leaves

    [Tooltip("Tile placed at the very top of the tree (crown).")]
    public TileData crownTile;        // crown sprite

    [Header("Height range (inclusive)")]
    [Min(4)] public int trunkHeightMin = 4;
    [Min(6)] public int trunkHeightMax = 6;

    [Header("Branch probability")]
    [Range(0f, 1f)] public float branchChance = 0.35f;

    /* ─────────────────────────  MAIN  ───────────────────────── */
    public override void PlaceStructure(World world, int x, int y)
    {
        if (!HasFreeSpace(world, x, y) ||
            trunkTile == null || leafTile == null || crownTile == null)
            return;

        int height = Random.Range(trunkHeightMin, trunkHeightMax + 1);

        /* 1 ▸ trunk & optional side leaves */
        for (int i = 0; i < height; i++)
        {
            int ty = y + i;
            world.SetTileID(x, ty, trunkTile.tileID);

            bool canBranch = i > 1 && i < height - 1;          // skip the base & near-top
            if (canBranch && Random.value < branchChance)
            {
                world.SetTileID(x - 1, ty, leafTile.tileID);   // left leaf
                world.SetTileID(x + 1, ty, leafTile.tileID);   // right leaf
            }
        }

        /* 2 ▸ crown */
        int crownY = y + height;
        world.SetTileID(x, crownY, crownTile.tileID);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintAbandonedShip.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_AbandonedShip", menuName = "Game/World/Blueprint/Structure/Abandoned Ship")]
public class BlueprintAbandonedShip : BlueprintStructure
{
    [Header("Ship Dimensions (Pixel Map)")]
    // We’ll use a fixed 14×13 “pixel map” here.
    // If you want to scale it bigger, adjust the strings below or write more rows/cols.
    private const int SHIP_WIDTH  = 14;
    private const int SHIP_HEIGHT = 13;

    [Header("Tiles")]
    public TileData wallTile;       // Used for '#' in the map
    public TileData backgroundTile; // Used for 'B'
    public TileData chestTile;      // Used for 'C'

    /// <summary>
    /// A simple row-by-row character map that outlines a pixel-art ship silhouette.
    /// Legend:
    ///    '#' => wallTile (front layer)
    ///    'B' => backgroundTile (background layer)
    ///    'C' => chestTile (front layer)
    ///    '.' => empty/air (do nothing, or place air if desired)
    ///
    /// Each string must be exactly 14 characters wide. Top row = index 0, bottom = index 12.
    /// </summary>
    private string[] shipShape = new string[]
    {
        "........###...",  // row 0  (top)
        "........###...",
        ".......#####..",
        "....####.#####",
        "....#BB#.#BB##",
        "....#BB#.#BB##",
        "....####.#####",
        ".....#.......#",
        "...##########.",
        "..#BBBBBBBBB#.",
        ".#BBBCCCBBBB#.",
        ".#BBBBBBBBBB#.",
        "..##########.."  // row 12 (bottom)
    };

    /// <summary>
    /// Places the “abandoned ship” underground.  
    /// 1) Scans downward to find the first solid ground tile.  
    /// 2) Offsets the ship so it appears below that ground.  
    /// 3) Draws the pixel-art silhouette using wallTile, backgroundTile, and chestTile.
    /// </summary>
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // 1) Check required tiles
        if (wallTile == null || backgroundTile == null)
        {
            Debug.LogWarning("BlueprintAbandonedShip is missing wallTile or backgroundTile!");
            return;
        }

        // 2) Scan downward to find ground
        int groundY = FindGroundY(world, anchorX, anchorY);
        if (groundY < 0)
        {
            Debug.LogWarning("No solid ground found. Skipping Abandoned Ship placement.");
            return;
        }

        // Place the top row of the ship a few blocks under the ground
        int finalAnchorY = groundY - 2 - SHIP_HEIGHT; 
        if (finalAnchorY < 0)
        {
            Debug.LogWarning("Not enough space above the bottom boundary. Skipping ship placement.");
            return;
        }

        // 3) Iterate through each row/column of the shipShape array,
        //    and place the appropriate tile if needed.
        for (int row = 0; row < SHIP_HEIGHT; row++)
        {
            string rowData = shipShape[row];
            int worldY = finalAnchorY + row;

            for (int col = 0; col < SHIP_WIDTH; col++)
            {
                char c = rowData[col];
                int worldX = anchorX + col;

                switch (c)
                {
                    case '#':
                        // Place the wall tile in the front layer
                        world.SetTileID(worldX, worldY, wallTile.tileID, isBackground: false);
                        break;
                    case 'B':
                        // Place background in the background layer
                        world.SetTileID(worldX, worldY, backgroundTile.tileID, isBackground: true);
                        break;
                    case 'C':
                        // Place a chest (front layer) for portholes / loot
                        if (chestTile != null)
                        {
                            world.SetTileID(worldX, worldY, chestTile.tileID, isBackground: false);
                        }
                        else
                        {
                            // If no chest tile assigned, fallback to wall
                            world.SetTileID(worldX, worldY, wallTile.tileID, isBackground: false);
                        }
                        break;
                    case '.':
                    default:
                        // '.' = empty air. Do nothing, or place an “air” tile if desired.
                        break;
                }
            }
        }
    }

    /// <summary>
    /// Scans downward from (startX, startY) to find a solid tile in the front layer.
    /// Returns that tile’s Y or -1 if none is found.
    /// Adjust if your world uses negative Y or different bedrock rules.
    /// </summary>
    private int FindGroundY(World world, int startX, int startY)
    {
        int minValidY = 0; // or negative if your world uses negative Y
        for (int y = startY; y >= minValidY; y--)
        {
            int tileID = world.GetTileID(startX, y);
            if (tileID > 0)
            {
                TileData data = world.tiles.GetTileDataByIndex(tileID);
                if (data != null && data.behavior == BlockBehavior.Solid)
                {
                    return y;
                }
            }
        }
        return -1; // No ground found
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintBeeHive.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(
        fileName = "Blueprint_BeeHive",
        menuName  = "Game/World/Blueprint/Structure/Bee Honeycomb Hive")]
public class BlueprintBeeHive : BlueprintStructure
{
    /* ─────────────────────────  DIMENSIONS  ───────────────────────── */
    [Header("Hive Footprint (rough)")]
    [Min(12)] public int sizeX = 34;
    [Min(10)] public int sizeY = 26;

    [Tooltip("0 = perfect hex / teardrop, 1 = noisy / irregular")]
    [Range(0f,1f)] public float contourNoise = 0.4f;

    /* ─────────────────────────  TILES  ───────────────────────────── */
    [Header("Tiles")]
    public TileData hiveBlockTile;     // solid shell (front)
    public TileData honeycombWallTile; // background wall
    public TileData honeyLiquidTile;   // honey (front)
    public TileData airTileOverride;   // optional – else UndergroundAir

    /* ───────────────────  HONEY-POOL SETTINGS  ───────────────────── */
    [Header("Honey Pools")]
    [Range(0f,1f)] public float poolFillPercent = 0.30f;

    /* ---------------------------------------------------------------- */
    public override void PlaceStructure(World world,int ax,int ay)
    {
        /* safety ----------------------------------------------------- */
        if (!hiveBlockTile || !honeycombWallTile || !honeyLiquidTile)
        {  Debug.LogWarning("[BeeHive] Assign all mandatory TileData!"); return; }

        TileData airTile = airTileOverride ?? world.tiles.UndergroundAirTile;
        if (!airTile) { Debug.LogWarning("[BeeHive] UndergroundAirTile missing!"); return; }

        /* pre-compute ------------------------------------------------ */
        int halfW = sizeX/2, halfH = sizeY/2;
        int minX = ax-halfW, maxX = ax+halfW;
        int minY = ay-halfH, maxY = ay+halfH;

        float rx = halfW, ry = halfH;                     // base radii
        float noiseSeed = Random.Range(0f,10_000f);

        var cavityCells = new HashSet<Vector2Int>();

        /* 1 ── build outer shell + wall ----------------------------- */
        for(int y=minY; y<=maxY; ++y)
        {
            for(int x=minX; x<=maxX; ++x)
            {
                if (!InsideHiveShape(x-ax, y-ay, rx, ry, noiseSeed, contourNoise))
                    continue;

                world.SetTileID(x,y, hiveBlockTile.tileID, false);
                world.SetTileID(x,y, honeycombWallTile.tileID, true);
            }
        }

        /* 2 ── carve cavity & fill bottom with honey ---------------- */
        int cavRx = Mathf.RoundToInt(rx*0.55f);
        int cavRy = Mathf.RoundToInt(ry*0.55f);
        int poolTop = -cavRy + Mathf.RoundToInt(cavRy*poolFillPercent);

        for(int dy=-cavRy; dy<=cavRy; ++dy)
        {
            float yy = dy/(float)cavRy;
            for(int dx=-cavRx; dx<=cavRx; ++dx)
            {
                float xx = dx/(float)cavRx;
                if (xx*xx+yy*yy>1f) continue;             // outside cavity

                int wx=ax+dx, wy=ay+dy;
                world.SetTileID(wx,wy, airTile.tileID,false);   // hollow centre

                if (dy<=poolTop)                              // honey pool
                    world.SetTileID(wx,wy,honeyLiquidTile.tileID,false);

                cavityCells.Add(new Vector2Int(wx,wy));
            }
        }
    }

    /* ---------------------------------------------------------------- */
    bool InsideHiveShape(int dx,int dy,float rx,float ry,
                         float seed,float noiseAmt)
    {
        /* base teardrop (ellipse that narrows towards top) */
        float nx = dx/rx;
        float ny = dy/ry;
        float baseShape = nx*nx + ny*ny*(1f+0.8f*mathfAbs(ny)); // fattens bottom

        if (baseShape>1f) return false;

        /* six-lobed “honey-comb” scallop (polar) */
        float angle = Mathf.Atan2(ny, nx);                    // –π … π
        float scallop = 0.12f * Mathf.Cos(angle*6f);          // 6 bumps
        float radiusAdj = 1f + scallop;

        /* noise for irregularity */
        float n = Mathf.PerlinNoise(seed+dx*0.15f, seed+dy*0.15f)-0.5f;

        /* point is inside if radius within adjusted boundary */
        float dist = Mathf.Sqrt(nx*nx+ny*ny);
        return dist <= radiusAdj - n*noiseAmt;
    }

    /* ---------------------------------------------------------------- */
    static float mathfAbs(float v)=> v<0?-v:v;

    public override BoundsInt GetStructureBounds(int ax,int ay)
    {
        int radX = Mathf.CeilToInt(sizeX*0.5f);
        int radY = Mathf.CeilToInt(sizeY*0.5f);
        return new BoundsInt(ax-radX, ay-radY,0, radX*2, radY*2,1);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintBigWormCave.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_BigWormCave", menuName = "Game/World/Blueprint/Structure/BigWormCave Blueprint")]
public class BlueprintBigWormCave : BlueprintStructure
{
    [Header("Tunnel Parameters")]
    public int wormTunnelLength = 50;
    public int tunnelRadius = 3;
    public float startAngleDeg = 0f;
    public float maxTurnAngle = 20f;
    [Range(0f, 1f)] public float turnChance = 0.3f;

    [Header("Cave Tile")]
    public TileData caveAirTile;
    public bool allowStartInAir = true;

    [Header("Radius Decrease Settings")]
    [Tooltip("If true, the tunnel radius gradually decreases from 'tunnelRadius' down to 1.")]
    public bool radiusDecreases = false;

    [Header("Side Tunnels")]
    [Tooltip("If true, occasionally spawn side tunnels at random steps of the main tunnel.")]
    public bool spawnSideTunnels = false;

    [Tooltip("Chance per step to spawn a side tunnel when spawnSideTunnels is enabled.")]
    [Range(0f, 1f)] public float sideTunnelChance = 0.05f;

    [Tooltip("Maximum length of each side tunnel, chosen randomly from 1..sideTunnelMaxLength.")]
    public int sideTunnelMaxLength = 10;

    [Tooltip("Radius of the side tunnels. Can be smaller than the main tunnel.")]
    public int sideTunnelRadius = 2;

    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        if (caveAirTile == null)
        {
            Debug.LogWarning("BlueprintCave requires 'caveAirTile' to carve out the tunnel!");
            return;
        }

        // Check if starting in air is allowed
        int startTileID = world.GetTileID(anchorX, anchorY);
        if (!allowStartInAir && startTileID <= 0)
        {
            Debug.Log("Cave start is in air tile, skipping because 'allowStartInAir' is false.");
            return;
        }

        float angleRad = startAngleDeg * Mathf.Deg2Rad;
        Vector2 currentPos = new Vector2(anchorX, anchorY);

        for (int i = 0; i < wormTunnelLength; i++)
        {
            // 1) Determine radius for this step (if shrinking is enabled)
            int currentRadius = ComputeCurrentRadius(i);

            // 2) Carve the main tunnel circle
            CarveCircle(world, currentPos, currentRadius);

            // 3) Possibly spawn a side tunnel
            if (spawnSideTunnels && Random.value < sideTunnelChance)
            {
                // Randomly decide how long the side tunnel will be
                int sideLength = Random.Range(1, sideTunnelMaxLength + 1);
                CarveSideTunnel(world, currentPos, sideLength);
            }

            // 4) Possibly turn left or right
            if (Random.value < turnChance)
            {
                float turnDeg = Random.Range(-maxTurnAngle, maxTurnAngle);
                angleRad += turnDeg * Mathf.Deg2Rad;
            }

            // 5) Move forward one tile
            currentPos.x += Mathf.Cos(angleRad);
            currentPos.y += Mathf.Sin(angleRad);
        }
    }

    /// <summary>
    /// Carves a side tunnel from a given start position for a certain length.
    /// Here we do a short random walk that can turn up to 'maxTurnAngle' each step,
    /// but use 'sideTunnelRadius' as the carving radius.
    /// </summary>
    private void CarveSideTunnel(World world, Vector2 startPos, int sideTunnelLength)
    {
        // Pick a random initial direction (0 to 360 degrees)
        float sideAngleRad = Random.Range(0f, 2f * Mathf.PI);
        Vector2 currentPos = startPos;

        for (int i = 0; i < sideTunnelLength; i++)
        {
            // Carve a smaller radius for side tunnels
            CarveCircle(world, currentPos, sideTunnelRadius);

            // Randomly turn
            float turnChanceLocal = 0.5f; // tweak or expose as a param if you prefer
            if (Random.value < turnChanceLocal)
            {
                float turnDeg = Random.Range(-maxTurnAngle, maxTurnAngle);
                sideAngleRad += turnDeg * Mathf.Deg2Rad;
            }

            // Move forward by 1 tile
            currentPos.x += Mathf.Cos(sideAngleRad);
            currentPos.y += Mathf.Sin(sideAngleRad);
        }
    }

    /// <summary>
    /// Computes the radius to carve at the current step, depending on whether
    /// 'radiusDecreases' is enabled.
    /// </summary>
    private int ComputeCurrentRadius(int currentStep)
    {
        if (!radiusDecreases)
        {
            return tunnelRadius;
        }

        float fraction = currentStep / (float)wormTunnelLength;
        int result = Mathf.FloorToInt(Mathf.Lerp(tunnelRadius, 1, fraction));
        return Mathf.Max(1, result);
    }

    /// <summary>
    /// Carves a circle of 'radius' around 'centerPos' by placing 'caveAirTile'.
    /// </summary>
    private void CarveCircle(World world, Vector2 centerPos, int radius)
    {
        int minX = Mathf.FloorToInt(centerPos.x - radius);
        int maxX = Mathf.FloorToInt(centerPos.x + radius);
        int minY = Mathf.FloorToInt(centerPos.y - radius);
        int maxY = Mathf.FloorToInt(centerPos.y + radius);

        for (int y = minY; y <= maxY; y++)
        {
            float dy = y - centerPos.y;
            for (int x = minX; x <= maxX; x++)
            {
                float dx = x - centerPos.x;
                float distSqr = dx * dx + dy * dy;
                if (distSqr <= radius * radius)
                {
                    world.SetTileID(x, y, caveAirTile.tileID, false);
                }
            }
        }
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintEggShape.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_EggShape", menuName = "Game/World/Blueprint/Structure/Egg Shape Blueprint")]
public class BlueprintEggShape : BlueprintStructure
{
    [Header("Egg Shape Dimensions")]
    public int eggWidth = 10;   // Horizontal diameter
    public int eggHeight = 14;  // Vertical diameter
    public int wallThickness = 2;  // Thickness of the border wall

    [Header("Tiles")]
    public TileData wallTile;
    public TileData heartTile;

    [Header("Fill Tiles (Optional)")]
    [Tooltip("Tile to fill the front layer. If null, no front tile will be placed.")]
    public TileData fillTileFront;

    [Tooltip("Tile to fill the background layer. If null, no background tile will be placed.")]
    public TileData fillTileBackground;


    [Header("Heart Shape Settings")]
    [Tooltip("Scale factor for the heart shape. Adjust to control the size of the heart in the center.")]
    public float heartScale = 3.0f;

    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // Verify required references
        if (wallTile == null || heartTile == null)
        {
            Debug.LogWarning("BlueprintEggShape missing required TileData references (wallTile or heartTile)!");
            return;
        }
        // fillTileFront & fillTileBackground are optional; we check for null before we use them.

        // Calculate half-width & half-height (radii)
        float rx = eggWidth / 2f;
        float ry = eggHeight / 2f;

        // Depending on anchor setting, determine the bounding box for iteration
        int minX, maxX, minY, maxY;
        if (anchorIsCenter)
        {
            minX = Mathf.FloorToInt(anchorX - rx);
            maxX = Mathf.FloorToInt(anchorX + rx);
            minY = Mathf.FloorToInt(anchorY - ry);
            maxY = Mathf.FloorToInt(anchorY + ry);
        }
        else
        {
            // When the anchor is at the bottom
            minX = Mathf.FloorToInt(anchorX - rx);
            maxX = Mathf.FloorToInt(anchorX + rx);
            minY = anchorY;
            maxY = anchorY + eggHeight;
        }

        // Determine the ellipse center based on anchor type
        float centerX = anchorIsCenter ? anchorX : (anchorX + rx);
        float centerY = anchorIsCenter ? anchorY : anchorY; // for non-centered, anchor is at bottom on Y

        // Loop over the bounding box of the ellipse
        for (int y = minY; y <= maxY; y++)
        {
            for (int x = minX; x <= maxX; x++)
            {
                // Compute relative coordinates
                float dx = x - centerX;
                float dy = y - centerY;

                // Check if (x, y) is inside the egg’s ellipse
                if (IsInsideEllipse(dx, dy, rx, ry))
                {
                    // Check if we're within the thick wall region
                    if (IsThickBorder(x, y, rx, ry, anchorX, anchorY, wallThickness))
                    {
                        // Place the wall tile in the front layer
                        world.SetTileID( x, y, wallTile.tileID, false);
                    }
                    // Otherwise, if inside the heart shape, place the heart tile in the front
                    else if (IsInsideHeartShape(dx, dy, heartScale))
                    {
                        world.SetTileID( x, y, heartTile.tileID, false);
                    }
                    else
                    {
                        // For the interior region that is not the thick border and not the heart:
                        // 1) (Optional) place a front tile if fillTileFront is not null
                        // 2) (Optional) place a background tile if fillTileBackground is not null

                        if (fillTileFront != null)
                        {
                            world.SetTileID( x, y, fillTileFront.tileID, false);
                        }

                        if (fillTileBackground != null)
                        {
                            // If you want to remove any existing tile in the background first, you could do:
                            //   WorldMapPostGenerator.SetTileID(world, x, y, world.tileDatabase.UndergroundAirTile.tileID, true);
                            // or skip that if you only want to overwrite.

                            world.SetTileID( x, y, fillTileBackground.tileID, true);
                        }
                    }
                }
            }
        }
    }

    // Checks if a point (dx, dy) is inside the ellipse defined by radii (rx, ry)
    bool IsInsideEllipse(float dx, float dy, float rx, float ry)
    {
        if (rx <= 0f || ry <= 0f) return false;
        float ellipseVal = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);
        return ellipseVal <= 1f;
    }

    // Determines if a cell is in the thick border region
    bool IsThickBorder(int cellX, int cellY, float rx, float ry, int anchorX, int anchorY, int thickness)
    {
        float centerX = anchorIsCenter ? anchorX : (anchorX + rx);
        float centerY = anchorIsCenter ? anchorY : anchorY;

        // Check the neighborhood within “thickness” range
        for (int offsetX = -thickness + 1; offsetX < thickness; offsetX++)
        {
            for (int offsetY = -thickness + 1; offsetY < thickness; offsetY++)
            {
                int nx = cellX + offsetX;
                int ny = cellY + offsetY;
                float ndx = nx - centerX;
                float ndy = ny - centerY;

                // If any neighbor is outside the ellipse, we're on the border
                if (!IsInsideEllipse(ndx, ndy, rx, ry))
                {
                    return true;
                }
            }
        }
        return false;
    }

    // Checks if a point is in the heart shape
    bool IsInsideHeartShape(float dx, float dy, float heartScale)
    {
        // Scale the relative coordinates
        float xNorm = dx / heartScale;
        float yNorm = dy / heartScale;

        // Classic implicit heart shape equation:
        //   (x^2 + y^2 - 1)^3 - x^2 * y^3 < 0
        return Mathf.Pow(xNorm * xNorm + yNorm * yNorm - 1, 3)
               - (xNorm * xNorm * Mathf.Pow(yNorm, 3)) < 0;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintFloatingIsland.cs
------------------------------
using UnityEngine;

/// <summary>
/// Generates an organically-shaped floating island and writes tiles via
/// <c>World.SetTileID(x, y, tileID, isBackground)</c>.
///
/// • <b>FrontLayerTiles</b>  → interior solid blocks (foreground)  
/// • <b>BackgroundLayerTiles</b> → interior wall tiles (background)
///
/// Extras  
/// ──────
/// • Grass cap (<see cref="grassTile"/>) on every exposed roof tile.  
/// • <b>dirtDepth</b> rows of <see cref="dirtTile"/> directly beneath that grass – they
///   overwrite existing tiles until air is reached.  
/// • Random trees on the grass (<see cref="treeChance"/>, <see cref="treeBlueprints"/>).  
/// • A buried-treasure chest (<see cref="chestTile"/>) one tile below the dirt layer,
///   centred on the island.
/// </summary>
[CreateAssetMenu(
    fileName = "Blueprint_FloatingIsland",
    menuName = "Game/World/Blueprint/Structure/Floating Island Blueprint")]
public class BlueprintFloatingIsland : BlueprintStructure
{
    #region Inspector
    [Header("Island Dimensions")]
    [Min(1)] public int radiusX = 10;
    [Min(1)] public int radiusY = 5;

    [Header("Surface Tiles")]
    public TileData grassTile;          // roof cap
    public TileData dirtTile;           // filler under grass
    [Min(1)] public int dirtDepth = 2;  // depth in tiles

    [Header("Biome Blocks (Interior Variants)")]
    public BiomeBlock FrontLayerTiles;      // solid blocks (e.g. dirt / stone)
    public BiomeBlock BackgroundLayerTiles; // walls

    [Header("Noise / Shape")]
    [Range(0f, 1f)] public float edgeNoiseStrength = 0.25f;
    public float edgeNoiseScale = 0.3f;
    public int   noiseSeed      = 0;

    [Header("Tree Settings")]
    [Range(0f, 1f)] public float treeChance = 0.3f;
    public BlueprintTree[] treeBlueprints;

    [Header("Buried Treasure")]
    public TileData chestTile;          // drag a chest block here
    public int chestYOffset = 1;        // how many tiles below the dirt layer
    #endregion
    //------------------------------------------------------------------

    public override void PlaceStructure(World world, int cx, int cy)
    {
        if (!ValidateBlocks()) return;

        WriteIsland(world, cx, cy);
        LayDirtUnderGrass(world, cx, cy);
        PlaceChest(world, cx, cy);
        MaybePlantTrees(world, cx, cy);
    }

    bool ValidateBlocks()
    {
        bool ok = true;
        if (FrontLayerTiles == null || FrontLayerTiles.subTiles is not { Length: >0 })
        { Debug.LogWarning("FrontLayerTiles must contain at least one subtile."); ok = false; }

        if (BackgroundLayerTiles == null || BackgroundLayerTiles.subTiles is not { Length: >0 })
        { Debug.LogWarning("BackgroundLayerTiles must contain at least one subtile."); ok = false; }

        if (grassTile == null || grassTile.tileID < 0)
            Debug.LogWarning("GrassTile is missing – roof will stay as interior block.");

        if (dirtTile == null || dirtTile.tileID < 0)
            Debug.LogWarning("DirtTile is missing – no dirt layer will be applied.");

        if (chestTile == null || chestTile.tileID < 0)
            Debug.LogWarning("ChestTile is missing – no treasure chest will spawn.");

        return ok;
    }

    //------------------------------------------------------------------
    #region Island Body
    void WriteIsland(World w, int cx, int cy)
    {
        int minX = cx - radiusX - 1, maxX = cx + radiusX + 1;
        int minY = cy - radiusY - 1, maxY = cy + radiusY + 1;
        float invRX2 = 1f / (radiusX * radiusX);
        float invRY2 = 1f / (radiusY * radiusY);

        // Track highest solid block in each X column
        int width = maxX - minX + 1;
        _topY = new int[width];
        for (int i = 0; i < width; i++) _topY[i] = int.MinValue;

        for (int y = minY; y <= maxY; y++)
        for (int x = minX; x <= maxX; x++)
        {
            float dx = x - cx, dy = y - cy;
            float ellipseVal = (dx * dx) * invRX2 + (dy * dy) * invRY2;
            float edge = Mathf.PerlinNoise((x + noiseSeed) * edgeNoiseScale,
                                           (y + noiseSeed) * edgeNoiseScale);
            if (ellipseVal > 1f + (edge - 0.5f) * 2f * edgeNoiseStrength) continue;

            float n = Mathf.PerlinNoise(
                (x + noiseSeed + FrontLayerTiles.NoiseOffset.x) * edgeNoiseScale,
                (y + noiseSeed + FrontLayerTiles.NoiseOffset.y) * edgeNoiseScale);

            int frontID = NearestThreshold(FrontLayerTiles.subTiles, n);
            int backID  = NearestThreshold(BackgroundLayerTiles.subTiles, n);

            if (frontID >= 0)
            {
                w.SetTileID(x, y, frontID, false);          // solid block
                int idx = x - minX;
                if (y > _topY[idx]) _topY[idx] = y;         // remember roof height
            }
            if (backID >= 0)
                w.SetTileID(x, y, backID, true);            // wall
        }

        // Grass pass
        if (grassTile != null && grassTile.tileID >= 0)
        {
            for (int col = 0; col < width; col++)
            {
                int y = _topY[col];
                if (y != int.MinValue)
                {
                    int x = minX + col;
                    w.SetTileID(x, y, grassTile.tileID, false);
                }
            }
        }

        _minX = minX;
        _minY = minY;
    }

    int[] _topY; int _minX; int _minY;
    #endregion

    //------------------------------------------------------------------
    #region Dirt Layer
    void LayDirtUnderGrass(World w, int cx, int cy)
    {
        if (dirtTile == null || dirtTile.tileID < 0 || dirtDepth <= 0 || _topY == null)
            return;

        int width = _topY.Length;
        for (int col = 0; col < width; col++)
        {
            int yGrass = _topY[col];
            if (yGrass == int.MinValue) continue;

            for (int d = 1; d <= dirtDepth; d++)
            {
                int ty = yGrass - d; if (ty < _minY) break;
                int x  = _minX + col;

                int current = w.GetTileID(x, ty);
                if (current == 0) break; // reached air

                w.SetTileID(x, ty, dirtTile.tileID, false);
            }
        }
    }
    #endregion

    //------------------------------------------------------------------
    #region Buried Treasure
    void PlaceChest(World w, int cx, int cy)
    {
        if (chestTile == null || chestTile.tileID < 0 || _topY == null) return;

        int centreCol = cx - _minX;
        if (centreCol < 0 || centreCol >= _topY.Length) return;

        int yGrass = _topY[centreCol];
        if (yGrass == int.MinValue) return;

        int chestY = yGrass - dirtDepth - chestYOffset;
        if (chestY < _minY) chestY = _minY;

        // Skip if chest would end up in air
        if (w.GetTileID(cx, chestY) == 0) return;

        w.SetTileID(cx, chestY, chestTile.tileID, false);
    }
    #endregion

    //------------------------------------------------------------------
    #region Trees
    void MaybePlantTrees(World w, int cx, int cy)
    {
        if (treeBlueprints == null || treeBlueprints.Length == 0 || treeChance <= 0f) return;

        for (int x = cx - radiusX; x <= cx + radiusX; x++)
        {
            for (int y = cy + radiusY + 1; y >= cy - radiusY; y--)
            {
                if (!IsGrassTile(w.GetTileID(x, y))) continue;
                if (w.GetTileID(x, y + 1) > 0) break; // blocked

                if (Random.value < treeChance)
                {
                    BlueprintTree bp = treeBlueprints[Random.Range(0, treeBlueprints.Length)];
                    bp.PlaceStructure(w, x, y + 1); // trunk above grass
                }
                break; // next column
            }
        }
    }
    #endregion

    //------------------------------------------------------------------
    #region Helpers
    public override BoundsInt GetStructureBounds(int ax, int ay) =>
        new BoundsInt(ax - radiusX - 1, ay - radiusY - 1, 0,
                      (radiusX + 1) * 2 + 1, (radiusY + 1) * 2 + 1, 1);

    bool IsGrassTile(int id) =>
        ContainsTile(FrontLayerTiles, id) ||
        (grassTile != null && grassTile.tileID == id);

    static bool ContainsTile(BiomeBlock blk, int id)
    {
        if (blk == null || blk.subTiles == null) return false;
        foreach (var s in blk.subTiles)
            if (s.tileData != null && s.tileData.tileID == id) return true;
        return false;
    }

    static int NearestThreshold(BiomeSubTile[] subs, float n)
    {
        // assumes array sorted by ascending threshold
        int lo = 0, hi = subs.Length - 1;
        while (lo <= hi)
        {
            int mid = (lo + hi) >> 1;
            if (subs[mid].threshold < n) lo = mid + 1; else hi = mid - 1;
        }
        int low  = Mathf.Clamp(hi, 0, subs.Length - 1);
        int up   = Mathf.Clamp(lo, 0, subs.Length - 1);
        int pick = Mathf.Abs(n - subs[low].threshold) <= Mathf.Abs(n - subs[up].threshold)
                   ? low : up;
        return subs[pick].tileData ? subs[pick].tileData.tileID : -1;
    }
    #endregion
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintHouse.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_SimpleBox", menuName = "Game/World/Blueprint/Structure/Simple Box Blueprint")]
public class BlueprintSimpleBox : BlueprintStructure
{
    [Header("Box Dimensions")]
    public int boxWidth = 8;
    public int boxHeight = 6;

    [Header("Tiles")]
    public TileData wallTile;
    public TileData backgroundTile;
    public TileData chestTile;

    // ------------------------------------------------------------
    // OVERRIDE: We’ll scan downward before placing the box.
    // ------------------------------------------------------------
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // 1) Verify we have needed tile references
        if (wallTile == null || backgroundTile == null)
        {
            Debug.LogWarning("BlueprintSimpleBox missing required wallTile or backgroundTile!");
            return;
        }

        // 2) Try to find solid ground by scanning downward
        int groundY = FindGroundY(world, anchorX, anchorY);
        if (groundY < 0)
        {
            // Could not find ground, so skip placement
            Debug.LogWarning("No solid ground found. Skipping structure placement.");
            return;
        }

        // Place this box so that its bottom is just above the ground
        int finalAnchorY = groundY + 1; // The “floor” of the box sits on top of ground

        // 3) Compute bounding box for the house
        int minX = anchorX;
        int maxX = anchorX + boxWidth - 1;

        int minY = finalAnchorY;
        int maxY = finalAnchorY + boxHeight - 1;

        // 4) Fill rectangle with walls on the border, background in the interior
        for (int y = minY; y <= maxY; y++)
        {
            for (int x = minX; x <= maxX; x++)
            {
                bool onBorder = (x == minX || x == maxX || y == minY || y == maxY);
                if (onBorder)
                {
                    // Place wall in front layer
                    world.SetTileID(x, y, wallTile.tileID, isBackground: false);
                }
                else
                {
                    // Interior => place background tile
                    // (First overwrite front with air if you want an empty interior)
                    if (world.Data.tileDatabase.UndergroundAirTile != null)
                    {
                        world.SetTileID(x, y, world.Data.tileDatabase.UndergroundAirTile.tileID, isBackground: false);
                    }
                    // Then place the background tile
                    world.SetTileID(x, y, backgroundTile.tileID, isBackground: true);
                }
            }
        }

        // 5) Optionally place a chest in the center
        if (chestTile != null)
        {
            int chestX = (minX + maxX) / 2;
            int chestY = (minY + maxY) / 2;
            world.SetTileID(chestX, chestY, chestTile.tileID, isBackground: false);
        }
    }

    // ------------------------------------------------------------
    // Scans downward from the starting Y to find a solid tile.
    // Returns the Y coordinate of that solid tile, or -1 if not found.
    // ------------------------------------------------------------
    private int FindGroundY(World world, int startX, int startY)
    {
        // 1) Don’t search below world bounds
        int minValidY = 0; // If your world can go negative, adjust accordingly

        // 2) Move downward from startY
        for (int y = startY; y >= minValidY; y--)
        {
            // Retrieve the tile ID in the front layer (or “solid” layer)
            int tileID = world.GetTileID(startX, y);
            if (tileID > 0)
            {
                // Look up the TileData to see if it’s solid
                TileData tileData = world.tiles.GetTileDataByIndex(tileID);
                if (tileData != null && tileData.behavior == BlockBehavior.Solid)
                {
                    return y; // Found ground
                }
            }
        }

        // If we never found a solid tile, return -1
        return -1;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintIceTemple.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_IceTemple", menuName = "Game/World/Blueprint/Structure/Ice Temple Blueprint")]
public class BlueprintIceTemple : BlueprintStructure
{
    [Header("Temple Dimensions")]
    public int templeWidth = 12;
    public int templeHeight = 8;

    [Header("Tiles")]
    public TileData floorTile;
    public TileData wallTile;
    [Tooltip("Optional columns/pillars in the center.")]
    public TileData pillarTile;
    [Tooltip("Optional frozen water tile for a central pool.")]
    public TileData frozenWaterTile;

    [Header("Settings")]
    public bool placeFrozenPool = true;      // If true, place a frozen water pool in the center
    public bool placeColumns = true;         // If true, place some icy columns

    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        if (floorTile == null || wallTile == null)
        {
            Debug.LogWarning("BlueprintIceTemple is missing required TileData references (floorTile, wallTile)!");
            return;
        }

        // 1) Place the outer walls and floor
        PlaceOuterWallsAndFloor(world, anchorX, anchorY);

        // 2) Optionally place a frozen pool in the center
        if (placeFrozenPool && frozenWaterTile != null)
        {
            PlaceFrozenPool(world, anchorX, anchorY);
        }

        // 3) Optionally place columns/pillars inside
        if (placeColumns && pillarTile != null)
        {
            PlaceColumns(world, anchorX, anchorY);
        }
    }

    // ------------------------------------------------------------------------
    // Places a ring of walls around the perimeter (forming a rectangle),
    // and fills the interior floor with floorTile.
    // ------------------------------------------------------------------------
    void PlaceOuterWallsAndFloor(World world, int anchorX, int anchorY)
    {
        int left = anchorX;
        int right = anchorX + templeWidth - 1;
        int bottom = anchorY;
        int top = anchorY + templeHeight - 1;

        // Place walls along the edges
        for (int x = left; x <= right; x++)
        {
            // bottom edge
            world.SetTileID(  x, bottom, wallTile.tileID);
            // top edge
            world.SetTileID(  x, top, wallTile.tileID);
        }
        for (int y = bottom; y <= top; y++)
        {
            // left edge
            world.SetTileID(  left, y, wallTile.tileID);
            // right edge
            world.SetTileID(  right, y, wallTile.tileID);
        }

        // Fill interior floor
        for (int y = bottom + 1; y < top; y++)
        {
            for (int x = left + 1; x < right; x++)
            {
                world.SetTileID(  x, y, floorTile.tileID);
            }
        }
    }

    // ------------------------------------------------------------------------
    // Places a small rectangular "frozen water" area in the center.
    // ------------------------------------------------------------------------
    void PlaceFrozenPool(World world, int anchorX, int anchorY)
    {
        // For simplicity, let's create a 2x3 or 3x4 region in the center
        int poolWidth = Mathf.Max(2, templeWidth / 3);
        int poolHeight = Mathf.Max(2, templeHeight / 3);

        // Calculate the top-left corner of this pool
        int startX = anchorX + (templeWidth - poolWidth) / 2;
        int startY = anchorY + (templeHeight - poolHeight) / 2;

        for (int y = 0; y < poolHeight; y++)
        {
            for (int x = 0; x < poolWidth; x++)
            {
                int worldX = startX + x;
                int worldY = startY + y;
                world.SetTileID(  worldX, worldY, frozenWaterTile.tileID);
            }
        }
    }

    // ------------------------------------------------------------------------
    // Places columns/pillars in a simple grid inside the temple.
    // ------------------------------------------------------------------------
    void PlaceColumns(World world, int anchorX, int anchorY)
    {
        // We'll skip placing them too close to walls or the pool
        int margin = 2; 
        int left = anchorX + margin;
        int right = anchorX + templeWidth - margin;
        int bottom = anchorY + margin;
        int top = anchorY + templeHeight - margin;

        // Simple approach: place columns at intervals of 3 tiles
        for (int x = left; x < right; x += 3)
        {
            for (int y = bottom; y < top; y += 3)
            {
                world.SetTileID(  x, y, pillarTile.tileID);
            }
        }
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintLavaBall.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(
        fileName = "Blueprint_LavaBall",
        menuName  = "Game/World/Blueprint/Structure/Lava-Filled Ball")]
public class BlueprintLavaBall : BlueprintStructure
{
    /* ──────────────  SHAPE  ────────────── */
    [Header("Ball Dimensions")]
    [Min(4)] public int diameterX = 20;
    [Min(4)] public int diameterY = 20;

    [Header("Inner Room")]
    [Min(1)] public int innerRadius = 4;        // radius of *air* pocket

    /* ──────────────  TILES  ────────────── */
    [Header("Tiles")]
    public TileData lavaTile;                   // mandatory
    public TileData wallTile;                   // wall ring around the room
    public TileData chestTile;                  // single chest placed at centre
    public TileData airTileOverride;            // optional – else world.UndergroundAirTile

    /* ──────────────  MAIN  ────────────── */
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        /* safety checks ------------------------------------------------ */
        if (lavaTile == null || wallTile == null || chestTile == null)
        {
            Debug.LogWarning("[LavaBall] lavaTile, wallTile or chestTile missing!");
            return;
        }

        TileData airTile = airTileOverride ?? world.tiles.UndergroundAirTile;
        if (airTile == null)
        {
            Debug.LogWarning("[LavaBall] world.tiles.UndergroundAirTile is not set!");
            return;
        }

        /* ellipse radii & bounds -------------------------------------- */
        float rx = diameterX * 0.5f;
        float ry = diameterY * 0.5f;

        int minX = Mathf.FloorToInt(anchorX - rx);
        int maxX = Mathf.FloorToInt(anchorX + rx);
        int minY = Mathf.FloorToInt(anchorY - ry);
        int maxY = Mathf.FloorToInt(anchorY + ry);

        int innerR2        = innerRadius        * innerRadius;          // air
        int innerWallR2Min = (innerRadius + 0) * (innerRadius + 0);     // start of wall
        int innerWallR2Max = (innerRadius + 1) * (innerRadius + 1);     // 1-tile thick

        /* carve -------------------------------------------------------- */
        for (int y = minY; y <= maxY; y++)
        {
            for (int x = minX; x <= maxX; x++)
            {
                float dx = x - anchorX;
                float dy = y - anchorY;

                if (!InsideEllipse(dx, dy, rx, ry)) continue;  // outside ball

                float d2 = dx * dx + dy * dy;                  // distance² from centre

                // 1) inner AIR pocket
                if (d2 <= innerR2)
                {
                    world.SetTileID(x, y, airTile.tileID, false);
                    world.SetTileID(x, y, airTile.tileID, true);
                }
                // 2) 1-tile WALL ring
                else if (d2 > innerWallR2Min && d2 <= innerWallR2Max)
                {
                    world.SetTileID(x, y, wallTile.tileID, false);
                    world.SetTileID(x, y, wallTile.tileID, true);
                }
                // 3) remaining volume filled with LAVA (front only)
                else
                {
                    world.SetTileID(x, y, lavaTile.tileID, false);
                }
            }
        }

        /* centre chest ------------------------------------------------- */
        world.SetTileID(anchorX, anchorY, chestTile.tileID, false);
        world.SetTileID(anchorX, anchorY, chestTile.tileID, true); // optional: show in BG too
    }

    /* helpers ---------------------------------------------------------- */
    static bool InsideEllipse(float dx, float dy, float rx, float ry) =>
        (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1f;

    public override BoundsInt GetStructureBounds(int ax, int ay)
    {
        int radX = Mathf.CeilToInt(diameterX * 0.5f);
        int radY = Mathf.CeilToInt(diameterY * 0.5f);
        return new BoundsInt(ax - radX, ay - radY, 0,
                             radX * 2,  radY * 2, 1);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintMaze.cs
------------------------------
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Blueprint that carves an ORGANIC *perfect maze* (no loops) that feels like a long, coiling
/// snake with many false ends.  It uses a depth‑first recursive‑backtracker on a coarse grid,
/// then smooth‑carves circles along each corridor so it still looks natural.
/// Finally, it surrounds the carved space with solid walls of configurable thickness and
/// hides a chest TileData at the most distant dead‑end.
/// </summary>
[CreateAssetMenu(
    fileName = "Blueprint_SnakeLabyrinth",
    menuName = "Game/World/Blueprint/Structure/Snake Labyrinth Blueprint")] // NB: non‑breaking space shows nicer in Inspector
public class BlueprintSnakeLabyrinth : BlueprintStructure
{
    // ─────────────────────────  Exposed Parameters  ──────────────────────────
    [Header("General")]
    public bool allowStartInAir = true;
    [Tooltip("Maximum number of maze cells (corridor segments) before we stop carving.")]  
    public int maxMazeCells = 400;

    [Header("Grid & Shape")]
    [Tooltip("Tile distance between maze cell centres.")] public int cellStep = 4;
    public int initialTunnelRadius = 3;
    public bool radiusShrinks = true;

    [Header("Wall Settings")]
    [Tooltip("Solid wall thickness measured in tiles.")]
    public int wallThickness = 2;

    [Header("Tiles")]
    public TileData floorTile;   // carved space (air)
    public TileData wallTile;    // solid wall
    public TileData chestTile;   // treasure chest (placed like a tile)

    // ──────────────────────────────  Internals  ──────────────────────────────

    private readonly Vector2Int[] kCardinal =
    {
        new Vector2Int( 1, 0),  // East
        new Vector2Int(-1, 0),  // West
        new Vector2Int( 0, 1),  // South (Unity +Y)
        new Vector2Int( 0,-1)   // North
    };

    private struct CarveState
    {
        public Vector2Int cell;  // centre of current maze cell (grid coordinates)
    }

    // Compute carving radius based on how many cells we already visited
    private int ComputeRadius(int visitedCount)
    {
        if (!radiusShrinks) return initialTunnelRadius;
        float t = Mathf.Clamp01((float)visitedCount / maxMazeCells);
        return Mathf.Max(1, Mathf.FloorToInt(Mathf.Lerp(initialTunnelRadius, 1, t)));
    }

    // Carve filled circle at <pos> with <radius>
    private void CarveCircle(World world, Vector2 pos, int radius, HashSet<Vector2Int> carved)
    {
        int minX = Mathf.FloorToInt(pos.x - radius);
        int maxX = Mathf.FloorToInt(pos.x + radius);
        int minY = Mathf.FloorToInt(pos.y - radius);
        int maxY = Mathf.FloorToInt(pos.y + radius);
        float rSqr = radius * radius;

        for (int y = minY; y <= maxY; y++)
        {
            float dy = y - pos.y;
            for (int x = minX; x <= maxX; x++)
            {
                float dx = x - pos.x;
                if (dx * dx + dy * dy > rSqr) continue;
                world.SetTileID(x, y, floorTile.tileID, false);
                carved.Add(new Vector2Int(x, y));
            }
        }
    }

    // Carve a *corridor* (series of circles) between world‑space positions a → b.
    private void CarveCorridor(World world, Vector2Int a, Vector2Int b, int radius, HashSet<Vector2Int> carved)
    {
        int steps = Mathf.CeilToInt(Vector2Int.Distance(a, b));
        for (int i = 0; i <= steps; i++)
        {
            Vector2 pos = Vector2.Lerp(a, b, i / (float)steps);
            // Slight jitter for organic feel
            pos += Random.insideUnitCircle * 0.3f;
            CarveCircle(world, pos, radius, carved);
        }
    }

    // Paint solid walls around carved floor using simple distance test
    private void BuildWalls(World world, HashSet<Vector2Int> floor, int thickness)
    {
        int t = Mathf.Max(1, thickness);
        int rSqr = t * t;
        foreach (var p in floor)
        {
            for (int dy = -t; dy <= t; dy++)
            for (int dx = -t; dx <= t; dx++)
            {
                if (dx * dx + dy * dy > rSqr) continue;
                var n = new Vector2Int(p.x + dx, p.y + dy);
                if (floor.Contains(n)) continue; // keep floor
                world.SetTileID(n.x, n.y, wallTile.tileID, false);
            }
        }
    }

    // BFS to find farthest reachable floor cell
    private Vector2Int FindFurthest(HashSet<Vector2Int> floor, Vector2Int start)
    {
        var q = new Queue<Vector2Int>();
        var dist = new Dictionary<Vector2Int, int>();
        q.Enqueue(start); dist[start] = 0;
        Vector2Int best = start; int bestD = 0;

        while (q.Count > 0)
        {
            var p = q.Dequeue();
            int d = dist[p];
            if (d > bestD) { best = p; bestD = d; }

            // 4‑way
            foreach (var dir in kCardinal)
            {
                var n = p + dir;
                if (!floor.Contains(n) || dist.ContainsKey(n)) continue;
                dist[n] = d + 1; q.Enqueue(n);
            }
        }
        return best;
    }

    // ─────────────────────────────  Entry Point  ─────────────────────────────
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // Safety
        if (floorTile == null || wallTile == null || chestTile == null)
        {
            Debug.LogWarning($"{name}: floor/wall/chest tiles not assigned!");
            return;
        }
        if (!allowStartInAir && world.GetTileID(anchorX, anchorY) <= 0)
        {
            Debug.Log($"{name}: start in air but allowStartInAir false; abort.");
            return;
        }

        // Data containers
        var carved   = new HashSet<Vector2Int>();  // floor positions
        var visited  = new HashSet<Vector2Int>();  // maze cells visited
        var stack    = new Stack<Vector2Int>();    // DFS stack

        Vector2Int startCell = new Vector2Int(anchorX, anchorY);
        stack.Push(startCell); visited.Add(startCell);

        // Depth‑first recursive‑backtracker maze generation
        while (stack.Count > 0 && visited.Count < maxMazeCells)
        {
            var current = stack.Peek();
            // Gather unvisited neighbours (cardinal directions)
            var choices = new List<Vector2Int>();
            foreach (var dir in kCardinal)
            {
                var neigh = current + dir * cellStep;
                if (!visited.Contains(neigh)) choices.Add(neigh);
            }

            if (choices.Count == 0)
            {
                stack.Pop(); // dead‑end reached, backtrack
                continue;
            }

            // Choose random next cell
            var next = choices[Random.Range(0, choices.Count)];

            // Carve corridor current → next
            int radius = ComputeRadius(visited.Count);
            CarveCorridor(world, current, next, radius, carved);

            // Push next onto stack
            stack.Push(next);
            visited.Add(next);
        }

        // Build walls
        BuildWalls(world, carved, wallThickness);

        // Drop chest at furthest leaf
        Vector2Int chestPos = FindFurthest(carved, startCell);
        world.SetTileID(chestPos.x, chestPos.y, chestTile.tileID, false);
    }
}.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintMinerMine.cs
------------------------------
using UnityEngine;

/// <summary>
/// An ultra-advanced miner with:
///  - Horizontal tunneling (3 high, 2 wide),
///  - Vertical (down) and new Upward Tunneling,
///  - Cave detection and descent,
///  - Water/lava detection,
///  - Large “room” creation,
///  - Short side tunnels,
///  - Support beams, torches, bridging, chests, etc.
/// </summary>
[CreateAssetMenu(fileName = "Blueprint_UltraAdvancedMiner", menuName = "Game/World/Blueprint/Structure/UltraAdvancedMiner Blueprint")]
public class BlueprintUltraAdvancedMiner : BlueprintStructure
{
    [Header("General Miner Settings")]
    [Tooltip("Maximum total moves before the miner stops.")]
    public int maxDiggerMoves = 150;

    [Tooltip("If true, the miner stops if it goes out of bounds.")]
    public bool stopIfOutOfBounds = true;

    [Header("Tunnel Dimensions & Tiles")]
    [Tooltip("3-tile-high corridor, 2-tile-wide vertical shaft.")]
    public TileData airTile;       
    [Tooltip("Tile used for ladders when digging down.")]
    public TileData ladderTile;    
    [Tooltip("Tile used for torches (placed at intervals).")]
    public TileData torchTile;     
    [Tooltip("Tile used for bridging water or small gaps (optional).")]
    public TileData bridgeTile;
    [Tooltip("Tile used for support beams in corridors.")]
    public TileData supportBeamTile;
    [Tooltip("Tile used for chests. If null, no chests are placed.")]
    public TileData chestTile;

    [Header("Movement Chances")]
    [Tooltip("Chance each step to try going downward (3 to 6 tiles).")]
    [Range(0f, 1f)] public float randomDownChance = 0.1f;
    [Tooltip("Chance each step to try going upward (2 to 4 tiles).")]
    [Range(0f, 1f)] public float randomUpChance = 0.05f;
    [Tooltip("Chance each step to reverse horizontal direction (zigzag).")]
    [Range(0f, 1f)] public float directionChangeChance = 0.05f;

    [Header("Side Tunnels & Rooms")]
    [Tooltip("Chance each step to spawn a short horizontal side tunnel.")]
    [Range(0f, 1f)] public float sideTunnelChance = 0.02f;
    [Tooltip("Length range for side tunnels.")]
    public Vector2Int sideTunnelLengthRange = new Vector2Int(4, 8);

    [Tooltip("Chance each step to carve out a large room.")]
    [Range(0f, 1f)] public float roomChance = 0.01f;
    [Tooltip("Size range for large rooms (width x height).")]
    public Vector2Int roomSizeMin = new Vector2Int(5, 4);
    public Vector2Int roomSizeMax = new Vector2Int(10, 6);

    [Header("Other Features")]
    [Tooltip("Place a torch every X horizontal steps.")]
    public int torchSpacing = 5;
    [Tooltip("Chance each step to place a chest (0=never, 1=always).")]
    [Range(0f, 1f)] public float chestChance = 0.02f;
    [Tooltip("If true, allow stepping up a 1-tile obstacle.")]
    public bool allowSteppingUp = true;
    [Tooltip("If true, allow bridging 1-tile gaps.")]
    public bool allowBridgingGaps = true;
    [Tooltip("Place support beams every X horizontal moves (0=never).")]
    public int supportBeamSpacing = 8;

    // Internal state
    private Vector2Int position;  // Current miner foot position
    private int xDir;             // +1 = right, -1 = left
    private int stepsTaken;       // horizontal steps for torch, support beams
    private int horizontalSegments; // for optional logic if needed

    // ------------
    // PLACE STRUCTURE
    // ------------
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // Basic checks
        if (airTile == null)
        {
            Debug.LogWarning("UltraAdvancedMiner: 'airTile' is not assigned!");
            return;
        }
        if (ladderTile == null)
        {
            Debug.LogWarning("UltraAdvancedMiner: 'ladderTile' is not assigned!");
        }

        // Initialize
        position = new Vector2Int(anchorX, anchorY);
        xDir = (Random.value < 0.5f) ? 1 : -1; // random left or right
        stepsTaken = 0;
        horizontalSegments = 0;

        // Main loop
        for (int i = 0; i < maxDiggerMoves; i++)
        {
            // 1) Carve a horizontal corridor (3 high, 2 wide) at the current position
            CarveHorizontalCorridor(world, position, xDir);

            // 2) Place torches or support beams at intervals
            TryPlaceTorch(world);
            TryPlaceSupportBeam(world);

            // 3) Possibly place a chest
            if (chestTile && Random.value < chestChance)
            {
                // place chest near foot? or top? We'll do at foot for example
                SetTileSafe(world, position.x, position.y, chestTile);
            }

            // 4) If there's a cave below, descend
            if (IsCaveBelow(world, position))
            {
                DescendIntoCave(world, ref position);
                continue;
            }

            // 5) If we detect water or lava in front, decide to skip or place a bridge
            if (CheckAndHandleLiquid(world))
            {
                // If we bridged or skipped, continue so we don't do more horizontal logic now
                continue;
            }

            // 6) Random chance to dig downward
            if (Random.value < randomDownChance)
            {
                int lengthDown = Random.Range(3, 7);
                DigVertical(world, ref position, lengthDown, goingUp: false);
                continue;
            }

            // 7) Random chance to dig upward
            if (Random.value < randomUpChance)
            {
                int lengthUp = Random.Range(2, 5);
                DigVertical(world, ref position, lengthUp, goingUp: true);
                continue;
            }

            // 8) Possibly spawn a big room
            if (Random.value < roomChance)
            {
                CreateBigRoom(world, position, xDir);
            }

            // 9) Possibly spawn a side tunnel
            if (Random.value < sideTunnelChance)
            {
                CreateSideTunnel(world, position, xDir);
            }

            // 10) Possibly reverse direction
            if (Random.value < directionChangeChance)
            {
                xDir *= -1;
            }

            // 11) Step over small obstacles if allowed
            if (allowSteppingUp && IsOneTileObstacleInFront(world, position, xDir))
            {
                StepUpOneTile(world, ref position, xDir);
                position.x += xDir;
                stepsTaken++;
                continue;
            }

            // 12) Bridge a small gap if allowed
            if (allowBridgingGaps && IsOneTileGapInFront(world, position, xDir))
            {
                BridgeGap(world, position, xDir);
                position.x += xDir;
                stepsTaken++;
                continue;
            }

            // 13) Move horizontally by 1
            position.x += xDir;
            stepsTaken++;
            horizontalSegments++;

            // 14) Check out of bounds
            if (stopIfOutOfBounds && !IsInBounds(world, position))
            {
                break;
            }
        }
    }

    // ------------
    // HORIZONTAL CORRIDOR
    // ------------
    private void CarveHorizontalCorridor(World world, Vector2Int footPos, int dir)
    {
        // We carve 3 tiles tall, 2 tiles wide
        int startX = (dir > 0) ? footPos.x : footPos.x - 1;
        const int width = 2;
        const int height = 3;
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                SetTileSafe(world, startX + x, footPos.y + y, airTile);
            }
        }
    }

    // ------------
    // TORCH & SUPPORT BEAM LOGIC
    // ------------
    private void TryPlaceTorch(World world)
    {
        if (!torchTile || torchSpacing <= 0) return;
        if (stepsTaken > 0 && stepsTaken % torchSpacing == 0)
        {
            int torchX = (xDir > 0) ? position.x : (position.x + 1);
            int torchY = position.y + 2;
            SetTileSafe(world, torchX, torchY, torchTile);
        }
    }

    private void TryPlaceSupportBeam(World world)
    {
        if (!supportBeamTile || supportBeamSpacing <= 0) return;
        if (stepsTaken > 0 && stepsTaken % supportBeamSpacing == 0)
        {
            // Example: place support beams in the top row or the middle?
            // We'll place in the middle row for a “vertical post” look.
            int beamX = (xDir > 0) ? position.x : (position.x + 1);
            int beamY = position.y + 1;
            SetTileSafe(world, beamX, beamY, supportBeamTile);
        }
    }

    // ------------
    // CHEST LOGIC (already done inline above)
    // ------------

    // ------------
    // DETECT CAVE BELOW
    // ------------
    private bool IsCaveBelow(World world, Vector2Int footPos)
    {
        int belowID = world.GetTileID(footPos.x, footPos.y - 1);
        if (belowID < 0) return false; // OOB
        TileData td = world.tiles.GetTileDataByID(belowID);
        return (td != null && td == world.tiles.UndergroundAirTile);
    }

    private void DescendIntoCave(World world, ref Vector2Int footPos)
    {
        while (true)
        {
            footPos.y--;

            // Carve 2 wide, 2 high
            for (int w = 0; w < 2; w++)
            {
                SetTileSafe(world, footPos.x + w, footPos.y, airTile);
                SetTileSafe(world, footPos.x + w, footPos.y + 1, airTile);
            }
            // Place ladder in left column
            if (ladderTile)
            {
                SetTileSafe(world, footPos.x, footPos.y, ladderTile);
            }

            // OOB check
            if (stopIfOutOfBounds && !IsInBounds(world, footPos))
                break;

            // Found floor?
            int belowID = world.GetTileID(footPos.x, footPos.y - 1);
            if (belowID < 0) break;
            TileData belowData = world.tiles.GetTileDataByID(belowID);
            if (belowData != null && belowData != world.tiles.UndergroundAirTile)
                break;
        }
    }

    // ------------
    // DETECT & HANDLE LIQUIDS (WATER / LAVA)
    // ------------
    private bool CheckAndHandleLiquid(World world)
    {
        // Check the tile in front (xDir) at foot level or just below foot for water/lava
        // For simplicity, we’ll check the tile at (position + xDir, position.y).
        // If it’s water => place a small “bridge tile” or skip.
        // If it’s lava => skip or block with some tile.

        int frontX = position.x + xDir;
        int frontY = position.y;
        if (!IsInBounds(world, frontX, frontY)) return false;

        int frontID = world.GetTileID(frontX, frontY);
        if (frontID < 0) return false;

        TileData frontData = world.tiles.GetTileDataByID(frontID);
        if (frontData == null) return false;

        // If the tile's behavior is Liquid => possibly water or lava
        if (frontData.behavior == BlockBehavior.Liquid)
        {
            // Distinguish if it's water or lava (you could use more properties in TileData)
            bool isLava = (frontData.tileName.ToLower().Contains("lava"));

            // Option A: If water, place a bridge tile on top
            if (!isLava && bridgeTile != null)
            {
                // Place the “bridge tile” above the water so we can walk across
                SetTileSafe(world, frontX, frontY, bridgeTile);
                return true; // we bridged water
            }
            else if (isLava)
            {
                // Option B: For lava, we might decide to skip or fill it with stone
                Debug.Log("Encountered lava. Miner is skipping forward or reversing direction...");
                // Just skip the forward movement this turn or reverse direction
                xDir *= -1;
                return true; 
            }
        }
        return false;
    }

    // ------------
    // VERTICAL DIG (UP OR DOWN)
    // ------------
    private void DigVertical(World world, ref Vector2Int footPos, int length, bool goingUp)
    {
        int directionY = goingUp ? +1 : -1;
        for (int i = 0; i < length; i++)
        {
            footPos.y += directionY;

            // Carve 2 wide, 2 tall for headroom
            for (int w = 0; w < 2; w++)
            {
                SetTileSafe(world, footPos.x + w, footPos.y, airTile);
                SetTileSafe(world, footPos.x + w, footPos.y + 1*directionY, airTile);
            }
            // If going down, place ladder
            if (!goingUp && ladderTile)
            {
                SetTileSafe(world, footPos.x, footPos.y, ladderTile);
            }

            if (stopIfOutOfBounds && !IsInBounds(world, footPos))
                break;
        }
    }

    // ------------
    // BIG ROOM CREATION
    // ------------
    private void CreateBigRoom(World world, Vector2Int footPos, int dir)
    {
        // Pick random width, height in [roomSizeMin, roomSizeMax]
        int roomWidth = Random.Range(roomSizeMin.x, roomSizeMax.x + 1);
        int roomHeight = Random.Range(roomSizeMin.y, roomSizeMax.y + 1);

        // If dir>0, place the left edge at footPos.x, else shift to the left
        int startX = (dir > 0) ? footPos.x : (footPos.x - (roomWidth - 1));
        int startY = footPos.y;

        for (int y = 0; y < roomHeight; y++)
        {
            for (int x = 0; x < roomWidth; x++)
            {
                SetTileSafe(world, startX + x, startY + y, airTile);
            }
        }

        // Possibly place some chests in the corners
        if (chestTile)
        {
            SetTileSafe(world, startX, startY, chestTile); // bottom-left
            SetTileSafe(world, startX + roomWidth - 1, startY, chestTile); // bottom-right
        }

        // Possibly place support beams along the top row or some random positions
        if (supportBeamTile)
        {
            for (int x = 0; x < roomWidth; x += 3)
            {
                int beamX = startX + x;
                int beamY = startY + roomHeight - 1;
                SetTileSafe(world, beamX, beamY, supportBeamTile);
            }
        }
    }

    // ------------
    // SIDE TUNNEL CREATION
    // ------------
    private void CreateSideTunnel(World world, Vector2Int footPos, int mainDir)
    {
        // Pick a random direction for side: might be left, right, or even the same direction
        int sideDir = (Random.value < 0.5f) ? -mainDir : mainDir;
        // Random length
        int length = Random.Range(sideTunnelLengthRange.x, sideTunnelLengthRange.y + 1);

        Vector2Int cur = footPos;
        for (int i = 0; i < length; i++)
        {
            CarveHorizontalCorridor(world, cur, sideDir);

            // Possibly place a torch
            if (torchTile && i % torchSpacing == 0 && i > 0)
            {
                int tx = (sideDir > 0) ? cur.x : (cur.x + 1);
                int ty = cur.y + 2;
                SetTileSafe(world, tx, ty, torchTile);
            }

            // Step forward
            cur.x += sideDir;
            if (stopIfOutOfBounds && !IsInBounds(world, cur))
                break;
        }
    }

    // ------------
    // STEP OVER 1-TILE OBSTACLE
    // ------------
    private bool IsOneTileObstacleInFront(World world, Vector2Int footPos, int dir)
    {
        int fX = footPos.x + dir;
        int fY = footPos.y;
        int frontID = world.GetTileID(fX, fY);
        int aboveFrontID = world.GetTileID(fX, fY + 1);

        if (frontID < 0 || aboveFrontID < 0) return false;
        TileData frontTile = world.tiles.GetTileDataByID(frontID);
        TileData aboveTile = world.tiles.GetTileDataByID(aboveFrontID);

        if (!IsAirTile(world, frontTile) && IsAirTile(world, aboveTile))
        {
            // Check head clearance
            int headID = world.GetTileID(footPos.x, footPos.y + 2);
            if (headID >= 0)
            {
                TileData headTile = world.tiles.GetTileDataByID(headID);
                if (IsAirTile(world, headTile))
                {
                    return true;
                }
            }
        }
        return false;
    }

    private void StepUpOneTile(World world, ref Vector2Int footPos, int dir)
    {
        footPos.y++;
        CarveHorizontalCorridor(world, footPos, dir);
    }

    // ------------
    // BRIDGE GAPS
    // ------------
    private bool IsOneTileGapInFront(World world, Vector2Int footPos, int dir)
    {
        int gapX = footPos.x + dir;
        int gapY = footPos.y - 1;
        if (!IsInBounds(world, gapX, gapY)) return false;

        int tileBelow = world.GetTileID(gapX, gapY);
        if (tileBelow < 0) return false;

        TileData belowData = world.tiles.GetTileDataByID(tileBelow);
        if (belowData == null) return false;

        if (IsAirTile(world, belowData))
        {
            // Check if there's solid or out-of-bounds 2 tiles below, to ensure it's just a 1-tile gap
            int below2ID = world.GetTileID(gapX, gapY - 1);
            if (below2ID >= 0)
            {
                TileData below2 = world.tiles.GetTileDataByID(below2ID);
                if (!IsAirTile(world, below2))
                {
                    return true; // single-tile gap
                }
            }
        }
        return false;
    }

    private void BridgeGap(World world, Vector2Int footPos, int dir)
    {
        // We place a "bridge tile" or simply carve the corridor so the miner can step safely.
        // If you want a special tile, do so below:
        if (bridgeTile != null)
        {
            int bx = footPos.x + dir;
            int by = footPos.y - 1;
            SetTileSafe(world, bx, by, bridgeTile);
        }
        // Also carve the corridor at the new forward tile
        Vector2Int newPos = new Vector2Int(footPos.x + dir, footPos.y);
        CarveHorizontalCorridor(world, newPos, dir);
    }

    // ------------
    // HELPER METHODS
    // ------------
    private bool IsAirTile(World world, TileData tileData)
    {
        if (tileData == null) return true;
        if (tileData == world.tiles.SkyAirTile) return true;
        if (tileData == world.tiles.UndergroundAirTile) return true;
        return false;
    }

    private void SetTileSafe(World world, int x, int y, TileData tile)
    {
        if (tile == null) return;
        if (stopIfOutOfBounds && !IsInBounds(world, x, y)) return;
        world.SetTileID(x, y, tile.tileID, false);
    }

    private bool IsInBounds(World world, int x, int y)
    {
        int w = world.widthInChunks * world.chunkSize;
        int h = world.heightInChunks * world.chunkSize;
        return (x >= 0 && x < w && y >= 0 && y < h);
    }
    private bool IsInBounds(World world, Vector2Int pos) => IsInBounds(world, pos.x, pos.y);
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintOreVein.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(
        fileName = "Blueprint_OreVein",
        menuName = "Game/World/Blueprint/Structure/Ore Vein Blueprint")]
public class BlueprintOreVein : BlueprintStructure
{
    /* ────────────────────────────────────────────────────────────
       1 ▸ Ore choice (depth‑gated, weighted once per vein)
       ----------------------------------------------------------------*/
    [System.Serializable]
    public struct PossibleOre
    {
        public TileData oreTile;                 // required
        [Range(0.01f, 10f)] public float weight; // weight if depth fits
        [Range(0f,1f)] public float minDepthNorm;
        [Range(0f,1f)] public float maxDepthNorm;
    }

    [Header("Possible Ores (≥1)")]
    public PossibleOre[] possibleOres;

    /* ────────────────────────────────────────────────────────────
       2 ▸ Vein‑shape presets (weighted pick)
       ----------------------------------------------------------------*/
    [System.Serializable]
    public struct VeinShape
    {
        [Header("Main path length (random in range)")]
        public int   minVeinLength;
        public int   maxVeinLength;

        [Header("Main path size & turn")]
        public int   veinRadius;
        public bool  radiusTapers;
        [Tooltip("Start direction in degrees (0 = +X, 90 = +Y)")]
        public float startAngleDeg;
        public float maxTurnAngle;
        [Range(0f,1f)] public float turnChance;

        [Header("Branching")]
        public bool  spawnBranches;
        [Range(0f,1f)] public float branchChance;
        public int   branchMaxLength;
        public int   branchRadius;

        [Header("Fill‑rate per tile (0 = sparse, 1 = solid)")]
        [Range(0f,1f)] public float fillChance;

        [Header("Selection weight")]
        [Range(0.01f,10f)] public float weight;
    }

    [Header("Possible Vein Shapes (≥1)")]
    public VeinShape[] possibleShapes;

    /* ================================================================== */
    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        if (possibleOres == null || possibleOres.Length == 0)
        {
            Debug.LogWarning("OreVein blueprint needs possibleOres defined!");
            return;
        }
        if (possibleShapes == null || possibleShapes.Length == 0)
        {
            Debug.LogWarning("OreVein blueprint needs possibleShapes defined!");
            return;
        }

        int worldTilesY = world.heightInChunks * world.chunkSize;
        float startDepthNorm = Mathf.Clamp01(anchorY / (float)worldTilesY);

        // 1️⃣ choose ore suitable to depth
        TileData chosenOre = ChooseOreForDepth(startDepthNorm);
        if (chosenOre == null) { Debug.Log("No suitable ore – vein skipped."); return; }

        // 2️⃣ choose vein shape by weighted random
        VeinShape shape = ChooseShape();

        // 3️⃣ decide actual length within [min,max]
        int actualLength = Random.Range(shape.minVeinLength, shape.maxVeinLength + 1);
        if (actualLength <= 0) return;

        float fillChance = Mathf.Clamp01(shape.fillChance);

        float angleRad = shape.startAngleDeg * Mathf.Deg2Rad;
        Vector2 pos    = new(anchorX, anchorY);

        for (int step = 0; step < actualLength; step++)
        {
            int radius = shape.radiusTapers ?
                          Mathf.Max(1, Mathf.FloorToInt(Mathf.Lerp(shape.veinRadius, 1, step/(float)actualLength))) :
                          shape.veinRadius;

            CarveCircle(world, pos, radius, chosenOre, fillChance);

            if (shape.spawnBranches && Random.value < shape.branchChance)
                CarveBranch(world, pos,
                            Random.Range(3, shape.branchMaxLength + 1),
                            shape.branchRadius,
                            shape.maxTurnAngle,
                            chosenOre,
                            fillChance);

            if (Random.value < shape.turnChance)
                angleRad += Random.Range(-shape.maxTurnAngle, shape.maxTurnAngle) * Mathf.Deg2Rad;

            pos.x += Mathf.Cos(angleRad);
            pos.y += Mathf.Sin(angleRad);
        }
    }

    /* ================================================================== */
    /* helpers */
    /* ================================================================== */

    TileData ChooseOreForDepth(float depthNorm)
    {
        float total = 0f;
        foreach (var o in possibleOres)
            if (depthNorm >= o.minDepthNorm && depthNorm <= o.maxDepthNorm && o.oreTile)
                total += Mathf.Max(0.01f, o.weight);
        if (total == 0f) return null;

        float roll = Random.value * total;
        foreach (var o in possibleOres)
        {
            if (depthNorm < o.minDepthNorm || depthNorm > o.maxDepthNorm || !o.oreTile) continue;
            roll -= Mathf.Max(0.01f, o.weight);
            if (roll <= 0f) return o.oreTile;
        }
        return null;
    }

    VeinShape ChooseShape()
    {
        float total = 0f;
        foreach (var s in possibleShapes) total += Mathf.Max(0.01f, s.weight);
        float roll = Random.value * total;
        foreach (var s in possibleShapes)
        {
            roll -= Mathf.Max(0.01f, s.weight);
            if (roll <= 0f) return s;
        }
        return possibleShapes[^1];
    }

    // ------------------------------------------------------------------
    //  carving helpers (skip Air & Liquid) + per‑tile fill chance
    // ------------------------------------------------------------------
    void CarveCircle(World world, Vector2 center, int radius, TileData ore, float fillChance)
    {
        int minX = Mathf.FloorToInt(center.x - radius);
        int maxX = Mathf.FloorToInt(center.x + radius);
        int minY = Mathf.FloorToInt(center.y - radius);
        int maxY = Mathf.FloorToInt(center.y + radius);

        for (int y = minY; y <= maxY; y++)
        {
            float dy = y - center.y;
            for (int x = minX; x <= maxX; x++)
            {
                float dx = x - center.x;
                if (dx * dx + dy * dy > radius * radius) continue;
                if (Random.value > fillChance) continue; // sparse fill

                int existingID = world.GetTileID(x, y);
                if (existingID <= 0) continue; // out‑of‑bounds/void

                TileData existing = world.tiles.GetTileDataByID(existingID);
                if (existing == null) continue;
                if (existing.behavior == BlockBehavior.Air || existing.behavior == BlockBehavior.Liquid)
                    continue;                                  // leave liquids and air untouched

                world.SetTileID(x, y, ore.tileID, false);
            }
        }
    }

    void CarveBranch(World world, Vector2 start, int length, int radius, float maxTurn, TileData ore, float fillChance)
    {
        float angle = Random.Range(0f, 360f) * Mathf.Deg2Rad;
        Vector2 pos = start;

        for (int i = 0; i < length; i++)
        {
            CarveCircle(world, pos, radius, ore, fillChance);

            if (Random.value < 0.5f)
                angle += Random.Range(-maxTurn, maxTurn) * Mathf.Deg2Rad;

            pos.x += Mathf.Cos(angle);
            pos.y += Mathf.Sin(angle);
        }
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintPyramid.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Blueprint_Pyramid", menuName = "Game/World/Blueprint/Structure/Pyramid Blueprint")]
public class BlueprintPyramid : BlueprintStructure
{
    [Header("Pyramid Dimensions")]
    public int pyramidHeight = 10;

    [Header("Offsets")]
    [Tooltip("Offset from the anchor on X and Y axes. Positive moves the pyramid up/right, negative down/left.")]
    public int xOffset = 0;
    public int yOffset = 0;

    [Header("Tiles")]
    public TileData pyramidTile;         // The main tile used for the pyramid
    public TileData backgroundWallTile;  // Optional background tile
    public TileData airTile;             // The "air" tile used to carve tunnels/chambers
    public TileData chestTile;           // Represents your treasure chest

    [Tooltip("If true, the pyramid’s interior is left empty (only an outer ‘shell’).")]
    public bool hollowInside = false;

    public override void PlaceStructure(World world, int anchorX, int anchorY)
    {
        // Make sure we have the necessary tiles
        if (pyramidTile == null)
        {
            Debug.LogWarning("BlueprintPyramid is missing 'pyramidTile'!");
            return;
        }
        if (airTile == null)
        {
            Debug.LogWarning("BlueprintPyramid is missing 'airTile'!");
            return;
        }
        // chestTile is optional, so we don’t return even if it’s missing

        // Apply offsets to anchor
        anchorX += xOffset;
        anchorY += yOffset;

        // 1) Optional: place background walls for each row
        if (backgroundWallTile != null)
        {
            PlaceBackgroundWalls(world, anchorX, anchorY);
        }

        // 2) Place the main pyramid shape in the front layer
        PlacePyramidShape(world, anchorX, anchorY);

        // 3) If not hollow, carve out an internal passage
        if (!hollowInside)
        {
            CarveInternalTunnelAndRooms(world, anchorX, anchorY);
        }
    }

    // ------------------------------------------------------------------------
    // Helper to find the bottom Y of the pyramid if anchor is truly the center.
    // Then each “level” is rowY = bottomY + level.
    // ------------------------------------------------------------------------
    private int GetBottomY(int centerY)
    {
        // If we want the anchor to be the vertical center, half the pyramid is below anchorY.
        int halfHeight = pyramidHeight / 2;
        return centerY - halfHeight;
    }

    // ------------------------------------------------------------------------
    // Places background tiles row by row, matching the pyramid’s shape.
    // ------------------------------------------------------------------------
    void PlaceBackgroundWalls(World world, int centerX, int centerY)
    {
        int bottomY = GetBottomY(centerY);

        for (int level = 0; level < pyramidHeight; level++)
        {
            int rowY = bottomY + level;
            // The widest row is at level=0 => width = 2 * pyramidHeight
            int rowWidth = 2 * (pyramidHeight - level);
            // Center each row horizontally about centerX
            int rowLeft = centerX - (rowWidth / 2);

            // Fill the entire row in the background
            for (int x = 0; x < rowWidth; x++)
            {
                world.SetTileID(
                    rowLeft + x,
                    rowY,
                    backgroundWallTile.tileID,
                    isBackground: true
                );
            }
        }
    }

    // ------------------------------------------------------------------------
    // Places the main pyramid shape in the front layer.
    // If hollowInside == true, only places the “outline” per row.
    // ------------------------------------------------------------------------
    void PlacePyramidShape(World world, int centerX, int centerY)
    {
        int bottomY = GetBottomY(centerY);

        for (int level = 0; level < pyramidHeight; level++)
        {
            int rowY = bottomY + level;
            int rowWidth = 2 * (pyramidHeight - level);
            int rowLeft = centerX - (rowWidth / 2);

            if (hollowInside)
            {
                // Outline each row: place leftmost & rightmost
                if (rowWidth <= 2)
                {
                    // If the row is very narrow, fill it
                    for (int x = 0; x < rowWidth; x++)
                    {
                        world.SetTileID(rowLeft + x, rowY, pyramidTile.tileID);
                    }
                }
                else
                {
                    // Just place the edges
                    world.SetTileID(rowLeft, rowY, pyramidTile.tileID);
                    world.SetTileID(rowLeft + rowWidth - 1, rowY, pyramidTile.tileID);
                }
            }
            else
            {
                // Solid fill of pyramidTile
                for (int x = 0; x < rowWidth; x++)
                {
                    world.SetTileID(rowLeft + x, rowY, pyramidTile.tileID);
                }
            }
        }
    }

    // ------------------------------------------------------------------------
    // If the pyramid is not hollow, carve a tunnel & main chamber inside.
    // Overwrites some pyramid tiles with airTile.
    // ------------------------------------------------------------------------
    void CarveInternalTunnelAndRooms(World world, int centerX, int centerY)
    {
        int bottomY = GetBottomY(centerY);
        int topY = bottomY + pyramidHeight - 1;

        // A) Entrance is at the base’s horizontal center
        int entranceX = centerX;
        int entranceY = bottomY;

        // B) Corridor goes from bottom ~75% up
        int corridorTopY = bottomY + (int)(0.75f * pyramidHeight);

        // Carve a 1-wide vertical corridor
        for (int y = entranceY; y <= corridorTopY; y++)
        {
            world.SetTileID(entranceX, y, airTile.tileID);
        }

        // C) Main chamber near the top
        int chamberWidth = 5;
        int chamberHeight = 4;
        int chamberLeft = entranceX - (chamberWidth / 2);
        int chamberBottom = corridorTopY;

        CarveRect(world, chamberLeft, chamberBottom, chamberWidth, chamberHeight, airTile);

        // D) Place a chest in the chamber center
        if (chestTile != null)
        {
            int chestX = chamberLeft + (chamberWidth / 2);
            int chestY = chamberBottom + (chamberHeight / 2);
            world.SetTileID(chestX, chestY, chestTile.tileID);
        }

        // E) Optional: hidden side rooms
        CarveHiddenRoom(world, chamberLeft - 1, chamberBottom + 1, 3, 3, airTile);          
        CarveHiddenRoom(world, chamberLeft + chamberWidth - 2, chamberBottom + 1, 3, 3, airTile); 
    }

    // ------------------------------------------------------------------------
    // Overwrites a rectangular region in the front layer with carveTile (often air).
    // ------------------------------------------------------------------------
    void CarveRect(World world, int xStart, int yStart, int width, int height, TileData carveTile)
    {
        for (int y = yStart; y < yStart + height; y++)
        {
            for (int x = xStart; x < xStart + width; x++)
            {
                world.SetTileID(x, y, carveTile.tileID);
            }
        }
    }

    // ------------------------------------------------------------------------
    // A “hidden room” is just a carved-out rectangular area. 
    // If not connected by a corridor, it’s effectively secret.
    // ------------------------------------------------------------------------
    void CarveHiddenRoom(World world, int xStart, int yStart, int width, int height, TileData carveTile)
    {
        for (int y = yStart; y < yStart + height; y++)
        {
            for (int x = xStart; x < xStart + width; x++)
            {
                world.SetTileID(x, y, carveTile.tileID);
            }
        }
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintRandom.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;

/* ────────────────────────────────────────────────────────────────
   BlueprintRandomVariant – carve-only edition
   • Every pixel set is undergroundAir (front-layer)
   • No solid dirt/stone or water tiles are placed
   • 31 variants you can toggle on/off in the Inspector
   ─────────────────────────────────────────────────────────────── */

public enum RandomVariant
{
    /* core 11 */
    BlobFill, BlobHole, Column, SpikeDown, HeartRoom,
    Arch, Lake, CrossTunnel, Stalagmite, SlabPlate, DiagonalTunnel,
    /* +10 */
    ZigZagTunnel, Staircase, PillarCluster, Dome, Chasm,
    Boulder, Fissure, SineTunnel, VerticalShaft, SpiralStair,
    RuinsRoom, Bridge, Wedge, Crater, SwissCheese, SnakeTunnel,
    /* +5 */
    StepPyramid, HorizontalShaft, HoneycombPocket, SpiralColumn, PitTrap
}

[CreateAssetMenu(fileName = "Blueprint_RandomVariant",
                 menuName  = "Game/World/Blueprint/Structure/Random Variant")]
public class BlueprintRandomVariant : BlueprintStructure
{
    /* ── toggles ── */
    [Header("Variants Enabled")]
    public bool useBlobFill=true,useBlobHole=true,useColumn=true,useSpikeDown=true,
                useHeartRoom=true,useArch=true,useLake=true,useCrossTunnel=true,
                useStalagmite=true,useSlabPlate=true,useDiagonalTunn=true,
                useZigZagTunnel=true,useStaircase=true,usePillarCluster=true,
                useDome=true,useChasm=true,useBoulder=true,useFissure=true,
                useSineTunnel=true,useVerticalShaft=true,useSpiralStair=true,
                useRuinsRoom=true,useBridge=true,useWedge=true,useCrater=true,
                useSwissCheese=true,useSnakeTunnel=true,
                useStepPyramid=true,useHorizontalShaft=true,
                useHoneycombPocket=true,useSpiralColumn=true,usePitTrap=true;

    /* ── sizes & noise ── */
    [Header("Common Size Range")] public int minSize = 4, maxSize = 9;
    [Header("Blob Raggedness")]   [Range(0,1)] public float blobNoiseCutoff = .55f;
    public float blobNoiseFreq = .25f;

    /* ── ONLY tile we ever write ── */
    [Header("Underground-Air Tile")]
    public TileData undergroundAir;

    /* ============================================================ */
    public override void PlaceStructure(World w,int ax,int ay)
    {
        switch (Pick())
        {
            /* core 11 – all carve only */
            case RandomVariant.BlobFill:        DrawBlob(w,ax,ay,false); break;
            case RandomVariant.BlobHole:        DrawBlob(w,ax,ay,true);  break;
            case RandomVariant.Column:          DrawColumn(w,ax,ay);     break;
            case RandomVariant.SpikeDown:       DrawSpike(w,ax,ay);      break;
            case RandomVariant.HeartRoom:       DrawHeart(w,ax,ay);      break;
            case RandomVariant.Arch:            DrawArch(w,ax,ay);       break;
            case RandomVariant.Lake:            DrawBlob(w,ax,ay,true);  break; // just carve
            case RandomVariant.CrossTunnel:     DrawCross(w,ax,ay);      break;
            case RandomVariant.Stalagmite:      DrawSpike(w,ax,ay);      break;
            case RandomVariant.SlabPlate:       DrawSlab(w,ax,ay);       break;
            case RandomVariant.DiagonalTunnel:  DrawDiagonal(w,ax,ay);   break;

            /* +10 */
            case RandomVariant.ZigZagTunnel:    DrawZigZag(w,ax,ay);     break;
            case RandomVariant.Staircase:       DrawStaircase(w,ax,ay);  break;
            case RandomVariant.PillarCluster:   DrawPillars(w,ax,ay);    break;
            case RandomVariant.Dome:            DrawDome(w,ax,ay);       break;
            case RandomVariant.Chasm:           DrawChasm(w,ax,ay);      break;
            case RandomVariant.Boulder:         DrawBoulder(w,ax,ay);    break;
            case RandomVariant.Fissure:         DrawFissure(w,ax,ay);    break;
            case RandomVariant.SineTunnel:      DrawSine(w,ax,ay);       break;
            case RandomVariant.VerticalShaft:   DrawVertical(w,ax,ay);   break;
            case RandomVariant.SpiralStair:     DrawSpiralStair(w,ax,ay);break;
            case RandomVariant.RuinsRoom:       DrawRuins(w,ax,ay);      break;
            case RandomVariant.Bridge:          DrawBridge(w,ax,ay);     break;
            case RandomVariant.Wedge:           DrawWedge(w,ax,ay);      break;
            case RandomVariant.Crater:          DrawCrater(w,ax,ay);     break;
            case RandomVariant.SwissCheese:     DrawSwiss(w,ax,ay);      break;
            case RandomVariant.SnakeTunnel:     DrawSnake(w,ax,ay);      break;

            /* newest 5 */
            case RandomVariant.StepPyramid:     DrawStepPyramid(w,ax,ay);break;
            case RandomVariant.HorizontalShaft: DrawHorizontal(w,ax,ay); break;
            case RandomVariant.HoneycombPocket: DrawHoneycomb(w,ax,ay);  break;
            case RandomVariant.SpiralColumn:    DrawSpiralColumn(w,ax,ay);break;
            case RandomVariant.PitTrap:         DrawPit(w,ax,ay);        break;
        }
    }

    /* ── picker ── */
    RandomVariant Pick()
    {
        var bag=new List<RandomVariant>();
        void A(bool f,RandomVariant v){ if(f) bag.Add(v); }

        A(useBlobFill,RandomVariant.BlobFill);   A(useBlobHole,RandomVariant.BlobHole);
        A(useColumn,RandomVariant.Column);       A(useSpikeDown,RandomVariant.SpikeDown);
        A(useHeartRoom,RandomVariant.HeartRoom); A(useArch,RandomVariant.Arch);
        A(useLake,RandomVariant.Lake);           A(useCrossTunnel,RandomVariant.CrossTunnel);
        A(useStalagmite,RandomVariant.Stalagmite);A(useSlabPlate,RandomVariant.SlabPlate);
        A(useDiagonalTunn,RandomVariant.DiagonalTunnel);A(useZigZagTunnel,RandomVariant.ZigZagTunnel);
        A(useStaircase,RandomVariant.Staircase); A(usePillarCluster,RandomVariant.PillarCluster);
        A(useDome,RandomVariant.Dome);           A(useChasm,RandomVariant.Chasm);
        A(useBoulder,RandomVariant.Boulder);     A(useFissure,RandomVariant.Fissure);
        A(useSineTunnel,RandomVariant.SineTunnel);
        A(useVerticalShaft,RandomVariant.VerticalShaft);
        A(useSpiralStair,RandomVariant.SpiralStair);
        A(useRuinsRoom,RandomVariant.RuinsRoom); A(useBridge,RandomVariant.Bridge);
        A(useWedge,RandomVariant.Wedge);         A(useCrater,RandomVariant.Crater);
        A(useSwissCheese,RandomVariant.SwissCheese);
        A(useSnakeTunnel,RandomVariant.SnakeTunnel);
        A(useStepPyramid,RandomVariant.StepPyramid);
        A(useHorizontalShaft,RandomVariant.HorizontalShaft);
        A(useHoneycombPocket,RandomVariant.HoneycombPocket);
        A(useSpiralColumn,RandomVariant.SpiralColumn);
        A(usePitTrap,RandomVariant.PitTrap);

        if(bag.Count==0) bag.Add(RandomVariant.BlobHole);
        return bag[Random.Range(0,bag.Count)];
    }

    /* ── helper ── */
    void Carve(World w,int x,int y)
        => w.SetTileID(x,y,undergroundAir.tileID,false);

    /* ── basic shapes (all carve only) ── */

    void DrawBlob(World w,int cx,int cy,bool ragged)
    {
        int r=Random.Range(minSize,maxSize+1),rSq=r*r,seed=w.seed^(cx<<3)^cy;
        for(int y=-r;y<=r;++y)
        for(int x=-r;x<=r;++x){
            if(x*x+y*y>rSq) continue;
            if(ragged){
                float n=Mathf.PerlinNoise((x+seed)*blobNoiseFreq,(y+seed)*blobNoiseFreq);
                if(n>blobNoiseCutoff) continue;
            }
            Carve(w,cx+x,cy+y);
        }
    }

    void DrawColumn    (World w,int x,int y){ for(int i=0;i<maxSize;++i) Carve(w,x,y+i); }
    void DrawSpike     (World w,int x,int y){ for(int i=0;i<maxSize;++i) Carve(w,x-i,y+i); }
    void DrawHeart     (World w,int cx,int cy){ DrawBlob(w,cx,cy,true); }        // simple carve
    void DrawArch      (World w,int cx,int cy){ DrawBlob(w,cx,cy,true); }
    void DrawCross     (World w,int cx,int cy){ for(int i=-maxSize;i<=maxSize;++i){Carve(w,cx+i,cy);Carve(w,cx,cy+i);} }
    void DrawStalagmite(World w,int x,int y){ DrawSpike(w,x,y); }
    void DrawSlab      (World w,int cx,int cy){ for(int x=-maxSize;x<=maxSize;++x) Carve(w,cx+x,cy); }
    void DrawDiagonal  (World w,int x,int y){ for(int i=0;i<maxSize*3;++i) Carve(w,x+i,y-i); }

    void DrawZigZag(World w,int x,int y)
    {
        int seg=maxSize;
        for(int i=0;i<seg;++i) Carve(w,x+i,y);
        for(int i=0;i<seg;++i) Carve(w,x+seg-i,y+i);
        for(int i=0;i<seg;++i) Carve(w,x-seg+i,y+seg);
    }
    void DrawStaircase (World w,int x,int y){ for(int i=0;i<maxSize*2;++i) Carve(w,x+i,y-i); }

    void DrawPillars(World w,int cx,int cy)
    { int c=Random.Range(3,6); for(int p=0;p<c;++p){int off=Random.Range(-maxSize,maxSize);for(int y=0;y<maxSize;++y)Carve(w,cx+off,cy+y);} }

    void DrawDome (World w,int cx,int cy){ DrawBlob(w,cx,cy,false); }
    void DrawChasm(World w,int cx,int cy){ for(int y=0;y<maxSize*3;++y) for(int x=-maxSize/2;x<=maxSize/2;++x) Carve(w,cx+x,cy+y); }
    void DrawBoulder(World w,int cx,int cy){ DrawBlob(w,cx,cy,false); }
    void DrawFissure(World w,int sx,int sy){ for(int i=0;i<maxSize*3;++i){Carve(w,sx+i,sy+i);if(i%2==0)Carve(w,sx+i,sy+i+1);} }
    void DrawSine  (World w,int sx,int sy){ int len=maxSize*4; float f=.3f; for(int i=0;i<len;++i){int y=sy+Mathf.RoundToInt(Mathf.Sin(i*f)*minSize/2f);Carve(w,sx+i,y);} }
    void DrawVertical(World w,int x,int y){ for(int i=0;i<maxSize*4;++i) Carve(w,x,y+i);}
    void DrawSpiralStair(World w,int cx,int cy){ int r=minSize, i=0; float step=.8f; for(float a=0;a<12.57f;a+=step,i++){Carve(w,cx+Mathf.RoundToInt(Mathf.Cos(a)*r),cy+Mathf.RoundToInt(Mathf.Sin(a)*r)+i/4);} }

    void DrawRuins(World w,int cx,int cy){ DrawBlob(w,cx,cy,true); }
    void DrawBridge(World w,int cx,int cy){ for(int x=-maxSize;x<=maxSize;++x) for(int y=0;y<2;++y) Carve(w,cx+x,cy-y);}
    void DrawWedge (World w,int sx,int sy){ for(int y=0;y<maxSize;++y) for(int x=0;x<=y;++x) Carve(w,sx+x,sy-y); }
    void DrawCrater(World w,int cx,int cy){ DrawBlob(w,cx,cy,false); }
    void DrawSwiss (World w,int cx,int cy){ DrawBlob(w,cx,cy,true); }
    void DrawSnake (World w,int x,int y){ int s=maxSize*5; for(int i=0;i<s;++i){Carve(w,x,y);x+=Random.Range(-1,2);y+=Random.Range(-1,2);} }

    /* newest 5 */
    void DrawStepPyramid(World w,int cx,int cy){ for(int l=0;l<4;++l){int half=maxSize-l*minSize;for(int y=0;y<minSize;++y)for(int x=-half;x<=half;++x)Carve(w,cx+x,cy-y-l*minSize);} }
    void DrawHorizontal (World w,int cx,int cy){ for(int x=-maxSize*2;x<=maxSize*2;++x) Carve(w,cx+x,cy); }
    void DrawHoneycomb  (World w,int cx,int cy){ int r=maxSize; for(int y=-r;y<=r;++y) for(int x=-r;x<=r;++x) if(((x+y)&1)==0) Carve(w,cx+x,cy+y); }
    void DrawSpiralColumn(World w,int cx,int cy){ int h=maxSize*2, r=2; for(int y=0;y<h;++y){float a=y*.5f;Carve(w,cx+Mathf.RoundToInt(Mathf.Cos(a)*r),cy+y);Carve(w,cx-Mathf.RoundToInt(Mathf.Cos(a)*r),cy+y);} }
    void DrawPit(World w,int cx,int cy){ for(int x=-3;x<=3;++x) for(int y=0;y<maxSize*3;++y) Carve(w,cx+x,cy+y); }

    /* bounds */
    public override BoundsInt GetStructureBounds(int ax,int ay)
    {
        int r=maxSize*6;
        return new BoundsInt(ax-r,ay-r,0,r*2+1,r*2+1,1);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintSpiderCave.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(
        fileName = "Blueprint_SpiderCave",
        menuName  = "Game/World/Blueprint/Structure/Spider Cave")]
public class BlueprintSpiderCave : BlueprintStructure
{
    /* ───────────── tunables ───────────── */

    [Header("Tiles")]
    public TileData webTile;   // required
    public TileData wallTile;  // optional

    [Header("Web Fill")]
    [Range(0f,1f)] public float webFillChance = 1f;
    public int   maxFloodSize = 10_000;

    [Header("Wall Rim")]
    [Min(1)] public int wallThickness = 1;

    /* ───────────── main ───────────── */

    public override void PlaceStructure(World w,int ax,int ay)
    {
        if (!webTile) return;
        if (!w.IsUndergroundAir(w.GetTileID( ax, ay))) return;

        /* 1 ─ flood-fill underground air cavity (4-way) */
        var cavity   = new HashSet<Vector2Int>();
        var frontier = new Queue<Vector2Int>();

        Vector2Int start = new(ax, ay);
        cavity.Add(start);
        frontier.Enqueue(start);

        Vector2Int[] dirs =
            { Vector2Int.up, Vector2Int.down, Vector2Int.left, Vector2Int.right };

        while (frontier.Count>0 && cavity.Count<maxFloodSize)
        {
            Vector2Int p = frontier.Dequeue();
            foreach (var d in dirs)
            {
                Vector2Int n = p + d;
                if (cavity.Contains(n)) continue;
                if (w.IsUndergroundAir(w.GetTileID(n.x,n.y)))
                {
                    cavity.Add(n);
                    frontier.Enqueue(n);
                    if (cavity.Count >= maxFloodSize) break;
                }
            }
        }

        /* 2 ─ weave webs */
        foreach (var pos in cavity)
            if (Random.value <= webFillChance)
                w.SetTileID( pos.x,pos.y, webTile.tileID);

        /* 3 ─ optional stone rim */
        if (!wallTile) return;

        var rim = new HashSet<Vector2Int>();
        foreach (var core in cavity)
        {
            for (int dx=-wallThickness; dx<=wallThickness; ++dx)
            for (int dy=-wallThickness; dy<=wallThickness; ++dy)
            {
                if (dx==0 && dy==0) continue;
                Vector2Int r = core + new Vector2Int(dx,dy);
                if (cavity.Contains(r) || rim.Contains(r)) continue;
                if (!w.IsLiquid( w.GetTileID(r.x,r.y)))
                    rim.Add(r);
            }
        }
        foreach (var p in rim)
            w.SetTileID(p.x,p.y, wallTile.tileID);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintStructure.cs
------------------------------
using UnityEngine;

public abstract class BlueprintStructure : Blueprint
{
    [Header("Placement Constraints")]
    [Tooltip("If true, this structure requires all its cells be within the world bounds. " +
             "If false, partial out-of-bounds placement is allowed.")]
    public bool requiresFullInBounds = true;
    public bool canBePlacedInAir = false;
    [Tooltip("How wide (in tiles) the structure is. For certain shapes, may be approximate.")]
    public int structureWidth = 1;

    [Tooltip("How tall (in tiles) the structure is. For certain shapes, may be approximate.")]
    public int structureHeight = 1;

    [Tooltip("If true, treat (anchorX, anchorY) as the center of the structure. " +
             "If false, treat it as the bottom of the structure (or top, or corner—your choice).")]
    public bool anchorIsCenter = true;
    
    // ------------------------------------------------------------------------
    // The base bounding box is a simple rectangle:
    // If anchorIsCenter => bounding box is centered at (anchorX, anchorY).
    // Else => bounding box extends from anchor to anchor + (width, height).
    // Child classes can override for custom shapes (egg, circle, irregular, etc.).
    // ------------------------------------------------------------------------
    public virtual BoundsInt GetStructureBounds(int anchorX, int anchorY)
    {
        // For 2D, the Z dimension is unused: set sizeZ=1 and position.z=0
        if (structureWidth < 1 || structureHeight < 1)
        {
            // Degenerate size => just a single tile at anchor
            return new BoundsInt(anchorX, anchorY, 0, 1, 1, 1);
        }

        if (anchorIsCenter)
        {
            // If anchored at center => bounding box is centered around (anchorX, anchorY).
            // For an even dimension, you can round or floor. Here we floor to get an integer box.
            int halfW = structureWidth / 2;
            int halfH = structureHeight / 2;

            int minX = anchorX - halfW;
            int minY = anchorY - halfH;
            return new BoundsInt(
                minX,          // x
                minY,          // y
                0,             // z
                structureWidth, 
                structureHeight, 
                1
            );
        }
        else
        {
            // If not anchored at center => interpret anchor as the "bottom" of the structure.
            // That means the bounding box goes from (anchorX, anchorY)
            // up to (anchorX+width-1, anchorY+height-1).
            return new BoundsInt(
                anchorX,
                anchorY,
                0,
                structureWidth,
                structureHeight,
                1
            );
        }
    }

    // ------------------------------------------------------------------------
    // Checks if the structure can be placed in bounds.
    // If requiresFullInBounds = false => always OK.
    // Else we do a bounding box check to ensure entire structure is in the world.
    // ------------------------------------------------------------------------
    public virtual bool CanPlaceStructure(World world, int anchorX, int anchorY)
    {
        // If we do not require full in-bounds => no check needed
        if (!requiresFullInBounds)
            return true;

        // Otherwise, we do a bounding box check
        BoundsInt bounds = GetStructureBounds(anchorX, anchorY);

        // Convert the bounding box corners to max/min (since BoundsInt is (position + size))
        int minX = bounds.xMin;
        int minY = bounds.yMin;
        int maxX = bounds.xMax - 1;
        int maxY = bounds.yMax - 1;

        // Grab the world’s max valid indexes
        int worldMaxX = world.widthInChunks * world.chunkSize - 1;
        int worldMaxY = world.heightInChunks * world.chunkSize - 1;

        // If the bounding box extends out of the valid range => can't place
        if (minX < 0 || minY < 0 || maxX > worldMaxX || maxY > worldMaxY)
        {
            return false;
        }

        return true;
    }

    // Each child blueprint must implement the actual tile placement
    public override abstract void PlaceStructure(World world, int anchorX, int anchorY);
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintUndergroundForest.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(
        fileName = "Blueprint_HorizontalForestCave",
        menuName  = "Game/World/Blueprint/Structure/Horizontal Forest Cave")]
public class BlueprintHorizontalForestCave : BlueprintStructure
{
    /* ─────────────────────────  SHAPE  ─────────────────────────────── */
    [Header("Cave Shape")]
    [Min(4)] public int caveLength  = 60;
    [Min(1)] public int caveRadius  = 6;

    [Min(0)] public int verticalAmplitude = 4;
    public float noiseScale = 0.05f;

    /* ─────────────────────────  SURFACE  ──────────────────────────── */
    [Header("Surface Tiles")]
    public TileData grassTile;              // optional – falls back to AreaData.defaultGrass
    public TileData dirtTile;               // optional – falls back to AreaData.defaultDirt
    [Min(1)] public int dirtDepth = 2;

    /* ─────────────────────────  INTERIOR  ─────────────────────────── */
    [Header("Interior Decoration")]
    public TileData foliageTile;
    [Range(0f,1f)] public float foliageFillChance = 0.4f;

    [Header("Trees")]
    public BlueprintTree[] treeBlueprints;   // optional – falls back to AreaData.defaultTrees
    [Range(0f,1f)] public float treeChance = 0.25f;

    /* ─────────────────────────  RIM “WALLS”  ─────────────────────────── */
    [Header("Rim Walls (now use dirtTile)")]
    [Min(1)] public int wallThickness = 1;

    /* ─────────────────────────  MAIN  ──────────────────────────────── */
    public override void PlaceStructure(World world, int ax, int ay)
    {
        AreaData area = world.GetArea(ax, ay);

        /* 1 → Area defaults win, blueprint fields are fallback */
        TileData grass = area?.defaultGrass ?? grassTile;
        TileData dirt  = area?.defaultDirt  ?? dirtTile;

        /* 2 → Tree list: area defaults first, else blueprint list */
        BlueprintTree[] trees =
            (area?.defaultTrees != null && area.defaultTrees.Length > 0)
                ? area.defaultTrees
                : (treeBlueprints != null && treeBlueprints.Length > 0
                       ? treeBlueprints
                       : null);

        if (grass == null)
        {
            Debug.LogWarning("HorizontalForestCave: no grass tile available (area & blueprint both unset).");
            return;
        }

        TileData uAir = world.tiles.UndergroundAirTile;
        if (uAir == null)
        {
            Debug.LogWarning("world.tileDatabase.UndergroundAirTile is missing!");
            return;
        }

        /* ───────── original cave-carving code (unchanged) ───────── */
        int halfLen = caveLength / 2;
        var air = new HashSet<Vector2Int>();
        var rng = new System.Random(ax ^ ay);
        float seedX = rng.Next(1, 10_000);

        for (int dx = -halfLen; dx <= halfLen; dx++)
        {
            float t  = (dx + halfLen) / (float)caveLength;
            float nC = Mathf.PerlinNoise(seedX + t * caveLength * noiseScale, 0f);
            float nR = Mathf.PerlinNoise(seedX + 1000 + t * caveLength * noiseScale, 0f);

            int cy  = ay + Mathf.RoundToInt((nC - .5f) * 2f * verticalAmplitude);
            int rad = Mathf.Max(1, Mathf.RoundToInt(caveRadius * Mathf.Lerp(0.6f, 1.3f, nR)));
            int wx  = ax + dx;

            for (int dy = -rad; dy <= rad; dy++)
            {
                int wy = cy + dy;
                if (dx*dx / (float)(halfLen*halfLen) + dy*dy / (float)(rad*rad) <= 1f)
                {
                    world.SetTileID(wx, wy, uAir.tileID, false);
                    air.Add(new Vector2Int(wx, wy));
                }
            }

            /* occasional side pockets */
            if (rng.NextDouble() < 0.05)
            {
                int pR = Mathf.Max(1, rad / 2);
                int oy = cy + rng.Next(-rad, rad + 1);
                int ox = wx + rng.Next(-rad, rad + 1);

                for (int py = -pR; py <= pR; py++)
                for (int px = -pR; px <= pR; px++)
                    if (px*px + py*py <= pR*pR)
                    {
                        int gx = ox + px, gy = oy + py;
                        world.SetTileID(gx, gy, uAir.tileID, false);
                        air.Add(new Vector2Int(gx, gy));
                    }
            }
        }

        /* identify floor */
        var floor = new List<Vector2Int>();
        var minY = new Dictionary<int, int>();
        foreach (var p in air)
            if (!minY.ContainsKey(p.x) || p.y < minY[p.x])
                minY[p.x] = p.y;
        foreach (var kv in minY)
            floor.Add(new Vector2Int(kv.Key, kv.Value));

        /* grass on floor */
        foreach (var pos in floor)
            world.SetTileID(pos.x, pos.y, grass.tileID, false);

        /* dirt layer under grass */
        if (dirt != null && dirtDepth > 0)
            foreach (var pos in floor)
                for (int d = 1; d <= dirtDepth; d++)
                {
                    var b = new Vector2Int(pos.x, pos.y - d);
                    if (air.Contains(b)) break;
                    world.SetTileID(b.x, b.y, dirt.tileID, false);
                }

        /* foliage */
        if (foliageTile != null && foliageFillChance > 0f)
            foreach (var pos in floor)
                if (air.Contains(pos + Vector2Int.up) && Random.value <= foliageFillChance)
                    world.SetTileID(pos.x, pos.y + 1, foliageTile.tileID, false);

        /* trees */
        if (trees != null && trees.Length > 0 && treeChance > 0f)
            foreach (var pos in floor)
                if (air.Contains(pos + Vector2Int.up) && Random.value <= treeChance)
                    trees[Random.Range(0, trees.Length)]
                         .PlaceStructure(world, pos.x, pos.y + 1);

        /* rim “walls” now use the same dirt tile -------------------- */
        if (dirt != null && wallThickness > 0)
        {
            int downReach = wallThickness + dirtDepth;
            var rim = new HashSet<Vector2Int>();

            foreach (var p in air)
                for (int dx = -wallThickness; dx <= wallThickness; dx++)
                for (int dy = -downReach;     dy <= wallThickness; dy++)
                {
                    if (dx == 0 && dy == 0) continue;
                    var n = new Vector2Int(p.x + dx, p.y + dy);
                    if (air.Contains(n) || rim.Contains(n)) continue;
                    if (world.GetTileID(n.x, n.y) == dirt.tileID) continue;  // already dirt
                    rim.Add(n);
                }

            foreach (var p in rim)
                world.SetTileID(p.x, p.y, dirt.tileID, false);
        }
    }

    /* —— bounds —— */
    public override BoundsInt GetStructureBounds(int ax, int ay) =>
        new BoundsInt(
            ax - caveLength/2 - wallThickness,
            ay - caveRadius - verticalAmplitude - wallThickness - dirtDepth,
            0,
            caveLength + wallThickness*2,
            caveRadius*2 + verticalAmplitude*2 + wallThickness*2 + dirtDepth,
            1);
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\BlueprintData\Blueprints\Structures\BlueprintUndergroundTree.cs
------------------------------
using UnityEngine;

/// <summary>
/// Massive underground tree with configurable taper, roots, branches and
/// multi-layer canopy.  No extra tiles are required – still uses the same
/// trunk / leaf / root TileData references.
/// </summary>
[CreateAssetMenu(fileName = "Blueprint_UndergroundTree",
                 menuName = "Game/World/Blueprint/Structure/Massive Underground Tree")]
public class BlueprintUndergroundTree : BlueprintStructure
{
    /* ───────────────────────── Inspector ───────────────────────── */

    [Header("Basic Dimensions")]
    [Min(3)] public int trunkHeight = 24;
    [Min(1)] public int trunkRadius = 2;
    [Min(2)] public int rootDepth   = 10;

    [Header("Tiles")]
    public TileData trunkTile;
    public TileData leafTile;
    public TileData rootTile;

    [Header("Taper & Branching")]
    [Range(0f, 0.8f)] public float taperPercent = 0.3f;
    [Min(2)] public int branchStep = 6;
    public Vector2Int branchLenMinMax = new(3, 5);

    [Header("Roots")]
    [Range(0f, 1f)] public float sideRootChance = 0.4f;

    [Header("Canopy")]
    [Min(3)] public int canopyRadius = 7;
    [Range(2, 5)] public int canopyLayers = 3;
    [Min(1)] public int canopyFalloff = 2;
    [Range(0f, 1f)] public float tendrilChance = 0.15f;

    [Header("Misc")]
    public bool isHollow = false;

    /* ───────────────────────── Entry ──────────────────────────── */

    public override void PlaceStructure(World w, int ax, int ay)
    {
        if (!ValidateTiles()) return;

        PlaceRoots(w, ax, ay);
        PlaceTaperedTrunk(w, ax, ay);
        PlaceCanopy(w, ax, ay + trunkHeight);
    }

    bool ValidateTiles()
    {
        if (trunkTile && rootTile && leafTile) return true;
        Debug.LogWarning("UndergroundTree blueprint missing tile references.");
        return false;
    }

    /* ───────────────────────── Roots ──────────────────────────── */

    void PlaceRoots(World w, int cx, int cy)
    {
        // main tap-root
        for (int y = 1; y <= rootDepth; y++)
            w.SetTileID(cx, cy - y, rootTile.tileID);

        // ring of diagonal side roots
        for (int depth = 1; depth <= rootDepth; depth++)
        {
            if (Random.value > sideRootChance) continue;

            int dirX = Random.value < 0.5f ? -1 : 1;
            int dirY = Random.value < 0.3f ? -1 : 0; // mostly horizontal
            int len  = Random.Range(2, trunkRadius * 3);

            int sx = cx; int sy = cy - depth;
            for (int i = 1; i <= len; i++)
            {
                sx += dirX; sy += dirY;
                w.SetTileID(sx, sy, rootTile.tileID);
            }
        }
    }

    /* ───────────────────────── Trunk ──────────────────────────── */

    void PlaceTaperedTrunk(World w, int cx, int cy)
    {
        for (int y = 1; y <= trunkHeight; y++)
        {
            float t = 1f - (y / (float)trunkHeight) * taperPercent;
            int r = Mathf.Max(1, Mathf.RoundToInt(trunkRadius * t));

            for (int dx = -r; dx <= r; dx++)
            {
                bool shell = Mathf.Abs(dx) == r;
                if (isHollow && !shell) continue;
                w.SetTileID(cx + dx, cy + y, trunkTile.tileID);
            }

            // branches every branchStep blocks
            if (y % branchStep == 0 && y < trunkHeight - 2)
                SpawnBranchRing(w, cx, cy + y, r);
        }
    }

    void SpawnBranchRing(World w, int bx, int by, int r)
    {
        int lenMin = branchLenMinMax.x;
        int lenMax = branchLenMinMax.y;

        SpawnBranch(w, bx + r, by, Vector2Int.right,  lenMin, lenMax);
        SpawnBranch(w, bx - r, by, Vector2Int.left,   lenMin, lenMax);
        SpawnBranch(w, bx,     by, Vector2Int.right + Vector2Int.up, lenMin, lenMax);
        SpawnBranch(w, bx,     by, Vector2Int.left  + Vector2Int.up, lenMin, lenMax);
    }

    void SpawnBranch(World w, int sx, int sy, Vector2Int dir, int lenMin, int lenMax)
    {
        int len = Random.Range(lenMin, lenMax + 1);
        int x = sx, y = sy;

        for (int i = 1; i <= len; i++)
        {
            x += dir.x;
            y += (i % 2 == 0) ? dir.y : 0; // slight upward curve
            w.SetTileID(x, y, trunkTile.tileID);

            // leaf tuft at the tip
            if (i == len)
                w.SetTileID(x, y + 1, leafTile.tileID);
        }
    }

    /* ───────────────────────── Canopy ─────────────────────────── */

    void PlaceCanopy(World w, int cx, int startY)
    {
        for (int layer = 0; layer < canopyLayers; layer++)
        {
            int r = canopyRadius - layer * canopyFalloff;
            int cy = startY + layer; // slight upward stack

            for (int dy = -r; dy <= r; dy++)
            {
                for (int dx = -r; dx <= r; dx++)
                {
                    // rough sphere + jitter
                    float noise = Random.Range(-0.4f, 0.4f);
                    if (dx * dx + dy * dy <= (r + noise) * (r + noise))
                    {
                        int wx = cx + dx;
                        int wy = cy + dy;
                        w.SetTileID(wx, wy, leafTile.tileID);

                        // hanging tendril
                        if (Random.value < tendrilChance && dy < 0)
                            SpawnTendril(w, wx, wy - 1);
                    }
                }
            }
        }
    }

    void SpawnTendril(World w, int sx, int sy)
    {
        int len = Random.Range(2, 5);
        for (int i = 0; i < len; i++)
        {
            int y = sy - i;
            if (w.GetTileID(sx, y) != 0) break;
            w.SetTileID(sx, y, leafTile.tileID);
        }
    }

    /* ───────────────────────── Bounds ─────────────────────────── */

    public override BoundsInt GetStructureBounds(int ax, int ay)
    {
        int r = Mathf.Max(trunkRadius, canopyRadius);
        int halfW = r + 2;
        int h = trunkHeight + canopyRadius + 2;
        int d = rootDepth + 2;
        return new BoundsInt(ax - halfW, ay - d, 0,
                             halfW * 2 + 1, h + d, 1);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\TileData.cs
------------------------------
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;
public enum BlockBehavior { Solid, Liquid, Air, Powder, Soil, Vine }
public enum BlockTag { Basic,Tree }
public enum BlockLayer { Solid, Background, Front }

[CreateAssetMenu(fileName = "Tile", menuName = "Game/World/new Tile")]
public class TileData : ScriptableObject
{
    public int tileID;

    [Header("Identification")]
    public string tileName;
    public Color color = Color.white;
    public TileBase tileBase;

    [Header("Properties")]
    public BlockBehavior behavior = BlockBehavior.Solid;
    public BlockTag tag = BlockTag.Basic;
    public BlockLayer layer = BlockLayer.Solid;
    public int health = 100;
    public int breakPowerRequired = 1;

    [Header("Lighting")]
    public float lightStrength = 0f;
    public Color lightColor = Color.clear;
    public float lightFalloff = 0.1f;



    [Tooltip("The tile that this tile should become once it has turned into grass.")]
    public TileData grassTile;

    public TileData vineTile;
    public int vineMinLength = 1;
    public int vineMaxLength = 6;

    [Tooltip("List of tile types this tile can grow on. For example, a sapling can only grow on Soil/Grass blocks.")]
    public List<TileData> canPlaceOnTiles;
    public BlueprintGrowable BlueprintGrowableMatured;
#if UNITY_EDITOR
    void OnValidate()
    {
        WorldTester2Notifier.NotifyChange();
    }
#endif
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\WorldData.cs
------------------------------
// ────────────────────────────────────────────────────────────────────────
//  WorldData.cs
// ────────────────────────────────────────────────────────────────────────
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

[CreateAssetMenu(fileName = "new World", menuName = "Game/World/new World")]
public class WorldData : ScriptableObject
{
    /* ─── Databases ─────────────────────────────────────────────── */
    [Header("Databases")]
    public TileDatabase      tileDatabase;
    public AreasDatabase     areasDatabase;
    public BiomeDatabase     biomeDatabase;
    public StructureDatabase structureDatabase;
    public OresDatabase      oresDatabase;

    /* ─── Generator seed ────────────────────────────────────────── */
    [Header("Generation Seed")]
    public int seed = 123;

    /* ─── Dimensions (chunks) ───────────────────────────────────── */
    [Header("World Dimensions (in Chunks)")]
    public int   chunkSize       = 16;
    public int   widthInChunks   = 64;
    public int   heightInChunks  = 32;
    public float overworldStarts = 0.5f;
    public float overworldDepth  = 0.2f;

    /* ─── World-scale biome mask ────────────────────────────────── */
    [Header("World-scale Biome Mask")]
    [Tooltip("Perlin frequency used to mask entire biomes (≤0 disables the mask)")]
    public float worldNoiseFrequency = 0f;   // 0 → feature disabled

    /* ─── Area (Voronoi) generation ────────────────────────────── */
    [Header("Area Generation (Voronoi)")]
    public Vector2Int areaGenerationSize = new(256, 256);
    public int        areaPointsCount    = 25;
    public int        areaOverworldStripes = 10;

    /* ─── Elevation noise ───────────────────────────────────────── */
    [Header("Elevation Noise")]
    public Vector2Int elevationGenerationSize = new(512, 512);
    public float      elevationNoiseScale     = 0.01f;
    public float      elevationNoiseIntensity = 1.0f;

    /* ─── Edge warp noise ───────────────────────────────────────── */
    [Header("Edge-warp Noise")]
    public float edgeNoiseScale     = 0.01f;
    public float edgeNoiseIntensity = 1.0f;

    /* ─── Skyline wave (cosine) ─────────────────────────────────── */
    [Header("Skyline Wave (cos)")]
    [Tooltip("Horizontal scale of the cosine skyline (smaller = more hills)")]
    public float skyLineWaveScale = 0.01f;
    [Tooltip("Vertical amplitude (0…1) of the skyline wave")]
    public float skyLineWaveAmplitude = 0.1f;

    /* ─── Skyline noise layers ──────────────────────────────────── */
    [Header("Skyline Noise (extra layers)")]
    [Tooltip("Adds gently undulating hills")]
    public float skyLowFreq  = 0.002f;
    public float skyLowAmp   = 0.20f;

    [Tooltip("Adds sharp ridges/mesas; keep small")]
    public float skyRidgeFreq = 0.01f;
    public float skyRidgeAmp  = 0.08f;
[Header("Skyline Mountains")]
[Tooltip("Lower = rarer, larger features (0.0003 … 0.002)")]
public float skyMountainFreq = 0.0008f;

[Tooltip("Vertical reach of tall peaks (0 … 0.6)")]
public float skyMountainAmp  = 0.35f;

[Tooltip("How deep valleys can carve below the cosine baseline (0 … 1)")]
public float skyValleyFactor = 0.5f;   // 0 = no valleys, 1 = valleys as tall as mountains

    /* ─── Skyline border blending ───────────────────────────────── */
    [Header("Skyline Blending")]
    [Tooltip("Columns over which skyline parameters blend between neighbouring areas")]
    [Range(0,16)] public int borderSmoothWidth = 4;

#if UNITY_EDITOR
    private void OnValidate() => WorldTester2Notifier.NotifyChange();
#endif
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Area\AreaData.cs
------------------------------
using UnityEngine;

public enum ZoneType
{
    Sky,
    Overworld,
    Underworld
}

[CreateAssetMenu(
        fileName = "Area_",
        menuName  = "Game/World/new Area Data")]
public class AreaData : ScriptableObject
{
    /* ─────────── Identification ─────────── */
    [Header("Identification")]
    public string   areaName;
    public Color    color = Color.white;
    public ZoneType zone;

    /* ─────────── Biomes & Noise ─────────── */
    [Header("Contained Biomes")]
    public BiomeData[] biomes;

    [Header("Noise")]
    [Tooltip("Per-area Perlin scale that decides which biome spawns where.")]
    public float areaNoiseFrequency = 0.003f;

    /* ─────────── Default Ground Blocks ─────────── */
    [Header("Default Ground Blocks")]
    [Tooltip("Fallback dirt block for this area.")]
    public TileData defaultDirt;

    [Tooltip("Fallback stone/rock block.")]
    public TileData defaultStone;

    [Tooltip("The grass block this area should use by default.")]
    public TileData defaultGrass;

    /* ─────────── Trees ─────────── */
    [Header("Tree Blueprints")]
    [Tooltip("Tree types this area is allowed to spawn by default.")]
    public BlueprintTree[] defaultTrees;
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Area\AreaOverworldData.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "Area_OW_", menuName = "Game/World/Area/Overworld Area")]
public class AreaOverworldData : AreaData
{
    /* ── Skyline modulation relative to the global cosine ───────── */
    [Header("Skyline Modifiers")]
    [Tooltip("Vertical shift applied to the cosine skyline (-0.05 … +0.05)")]
    [Range(-0.05f, 0.05f)] public float skyCosOffset = 0f;

    [Tooltip("Amplitude multiplier for the skyline wave (0.5 … 2.0)")]
    public float skyCosAmpMul = 1f;

    /* ── Single control that replaces four separate noise overrides ─ */
    [Header("Skyline Ruggedness")]
    [Tooltip("0 = smooth rolling hills, 1 = dramatic jagged peaks")]
   public float skylineRuggedness = -1f;   // <0 → auto

    /* ── Optional temperature tag ─────────────────────────────────── */
    [Header("Thermal Signature")]
    [Range(-1f, 1f)] public float heat = 0f;
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Area\AreaSkyworldData.cs
------------------------------
using UnityEngine;

// AreaSkyworldData.cs
[CreateAssetMenu(fileName = "Area_SW_", menuName = "Game/World/Area/Skyworld Area")]
public class AreaSkyworldData : AreaData
{
    [Header("Vertical band")]
    [Range(0f, 1f)] public float minDepth = 0f;
    [Range(0f, 1f)] public float maxDepth = 1f;

    [Header("Horizontal heat band  (+1 = far‑left, −1 = far‑right)")]
    [Range(-1f, 1f)] public float minHeat = -1f;
    [Range(-1f, 1f)] public float maxHeat =  1f;
}.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Area\AreaUnderworldData.cs
------------------------------
using UnityEngine;

// AreaUnderworldData.cs
[CreateAssetMenu(fileName = "Area_UW_", menuName = "Game/World/Area/Underworld Area")]
public class AreaUnderworldData : AreaData
{
    [Header("Vertical band")]
    [Range(0f, 1f)] public float minDepth = 0f;
    [Range(0f, 1f)] public float maxDepth = 1f;

    [Header("Horizontal heat band  (+1 = far‑left, −1 = far‑right)")]
    [Range(-1f, 1f)] public float minHeat = -1f;
    [Range(-1f, 1f)] public float maxHeat =  1f;
}.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Biome\BiomeData.cs
------------------------------
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

/* ──────────────────────────────────────────────────────────────────────────
   BiomeData
   ---------------------------------------------------------------------- */
public abstract class BiomeData : ScriptableObject
{
    /* 1 ▸ Basic info */
    [Header("Basic Info")]
    public string  biomeName = "New Biome";
    [TextArea] public string description = "Short biome blurb…";

    /* 2 ▸ Preview colour & map elevation */
    [Header("Display & Elevation")]
    public Color  color = Color.white;
    [Range(0f,1f)] public float elevation = 0.5f;

    /* 3 ▸ World‑scale mask (checked once per tile) – NEW */
    [Header("World‑scale Mask")]
    [Tooltip("If Perlin < threshold the biome is skipped at that coordinate")]
    [Range(0f,1f)] public float worldNoiseThreshold = 0f;   // 0 = always allowed

   [Header("Local Ores")]
public OreSetting[] localOres;   // uses the same OreSetting class as globals

    /* 5 ▸ Tile blocks */
    [Header("Tiles")]
    public BiomeBlock FrontLayerTiles;
    public BiomeBlock BackgroundLayerTiles;

    /* 6 ▸ Per‑biome FBm noise */
    [Header("Noise (per‑biome FBm)")]
    public NoiseType noiseType = NoiseType.Perlin;
    public float     frequency = 0.14f;
    public float     strength  = 1f;
    public Vector2   stretch   = Vector2.one;

    [Space(2)]
    [Range(1,8)] public int octaves = 1;
    public float   lacunarity  = 2f;
    public float   persistence = 0.5f;
    public Vector2 offset      = Vector2.zero;
    // NEW ────────────────────────────────────────────────

       /* 8 ▸ Foliage */
    [Header("Foliage")]
    [Tooltip("Probability that a foliage tile will be spawned above a surface block")]
    [Range(0f,1f)] public float foliageSpawnChance = 0.4f;

    [Tooltip("Decorative tiles that can appear above ground in this biome")]
    public TileData[] foliageTiles;
// Direct-spawned tree blueprints & chance
[Tooltip("Prefabs that can be spawned directly during world-gen")]
public BlueprintTree[] Trees;

    /* 7 ▸ Area‑noise blend (optional) */
    [Header("Area‑noise Blend")]
    [Range(0f,1f)] public float areaNoiseBlend = 0f;    // 0 = ignore area noise

    /* 8 ▸ Foliage */
    [Header("Foliage")]
    [Range(0f,1f)] public float vineChance = 0.3f;

    [Range(0f,1f)] public float treeSpawnChance= 0.3f;

#if UNITY_EDITOR
    private void OnValidate() => WorldTester2Notifier.NotifyChange();
#endif
}

/* ───────── helper types ───────── */
public enum NoiseType { Perlin, Simplex }

[System.Serializable]
public class BiomeBlock
{
    public Vector2        NoiseOffset;
    public BiomeSubTile[] subTiles;
}

[System.Serializable]
public class BiomeSubTile
{
    public TileData tileData;
    [Range(0f,1f)] public float threshold;
}

.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Biome\BiomeOverworldData.cs
------------------------------
using UnityEngine;
[CreateAssetMenu(fileName = "Biome_OW_", menuName = "Game/World/Biome/Overworld Biome")]
public class BiomeOverworldData : BiomeData
{
    [Header("Overworld Biome Settings")]
    public OverworldLayer[] overworldLayers;


        public float OverworldnoiseScale = 1f;
    public float OverworldnoiseIntensity = 1f;
}

[System.Serializable]
public class OverworldLayer
{
    public float minDepth = 0f;
    public float maxDepth = 3f;

    public BiomeSubTile[] FrontLayerTiles;
    public BiomeSubTile[] BackgroundLayerTiles;
}

.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Biome\BiomeSkyworldData.cs
------------------------------
using UnityEngine;
[CreateAssetMenu(fileName = "Biome_SW_", menuName = "Game/World/Biome/Skyworld Biome")]
public class BiomeSkyworldData : BiomeData
{
    [Header("Sky Biome Settings")]
    public float cloudCoverage = 0.5f;
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Data\World\Biome\BiomeUnderworldData.cs
------------------------------
using UnityEngine;
[CreateAssetMenu(fileName = "Biome_UW_", menuName = "Game/World/Biome/Underworld Biome")]
public class BiomeUnderworldData : BiomeData
{
    [Header("Underworld Biome Settings")]
    public float lavaFlowIntensity = 1f;
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\AreaDatabase.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "AreasDatabase", menuName = "Game/Database/New Areas Database")]
public class AreasDatabase : ScriptableObject
{
    public AreaData[] areas;

    public AreaData GetAreaData(int index)
    {
        if (index >= 0 && index < areas.Length)
            return areas[index];

        Debug.LogWarning($"Area index [{index}] is out of range.");
        return null;
    }
}

.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\biomeDatabase.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "BiomeDatabase", menuName = "Game/Database/New Biome Database")]
public class BiomeDatabase : ScriptableObject
{
    public BiomeData[] biomelist;

    public BiomeData GetBiomeData(int index)
    {
        if (index >= 0 && index < biomelist.Length)
        {
            return biomelist[index];
        }

        Debug.LogWarning($"BioMe index [{index}] is out of range.");
        return null;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\CraftingRecipeDatabase.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\ItemDatabase.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\OresDatabase.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;

#if UNITY_EDITOR
using UnityEditor;
#endif

/* ================================================================
   GlobalOresDatabase.cs
   ----------------------------------------------------------------
   Now supports an *exclusion* list of areas (AreaData) instead of
   a biome whitelist.
   ================================================================*/

[System.Serializable]
public class OreSetting
{
    [Header("Meta")]
    [Tooltip("Friendly name shown in the Inspector list")]
    public string oreName = "New Ore";
    /* ─────────── core ─────────── */
    [Header("Core")]
    public TileData oreTile;

    [Tooltip("Perlin frequency used to scatter this ore")]
    public float noiseFrequency = 0.02f;

    [Range(0f,1f)] public float threshold = 0.55f;
    [Range(0f,1f)] public float chance    = 0.25f;
    [Tooltip("XY offset added to (wx, wy) before sampling Perlin")]
    public Vector2 noiseOffset = Vector2.zero;
    /* ─────────── depth gate ───── */
    [Header("Depth range (0 = surface, 1 = bedrock)")]
    [Range(0f,1f)] public float minDepthNorm = 0f;
    [Range(0f,1f)] public float maxDepthNorm = 1f;

    /* ─────────── area filter ──── */
    [Header("Areas where this ore **CAN** spawn (leave empty = anywhere)")]
    public List<AreaData> allowedAreas;

    /* ─────────── host filter ──── */
    [Header("Valid host tiles (empty = any solid)")]
    public List<TileData> validHostTiles;
}

/* ---------------------------------------------------------------- */
[CreateAssetMenu(fileName = "OresDatabase",
                 menuName = "Game/Database/Global Ore Database")]
public class OresDatabase : ScriptableObject
{
    public OreSetting[] ores;

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (ores == null) return;
        foreach (var o in ores)
        {
            o.minDepthNorm = Mathf.Clamp01(o.minDepthNorm);
            o.maxDepthNorm = Mathf.Clamp01(o.maxDepthNorm);
            if (o.maxDepthNorm < o.minDepthNorm)
                o.maxDepthNorm = o.minDepthNorm;
        }
    }
#endif
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\ProjectileDatabase.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\StructureDatabase.cs
------------------------------
using UnityEngine;

[CreateAssetMenu(fileName = "StructureDatabase", menuName = "Game/Database/Structure Database")]
public class StructureDatabase : ScriptableObject
{
    [System.Serializable]
    public class StructureEntry
    {
        [Header("Structure Info")]
        public string structureName = "Unnamed Structure";
        public BlueprintStructure structureBlueprint;

        [Tooltip("Max times this structure can appear in a single world.")]
        public int maxSpawnsPerWorld = 1;

        [Tooltip("List of areas where this structure can spawn. If empty, it can spawn in ANY area.")]
        public AreaData[] allowedAreas;          // ⬅️ UUS

        [Header("Chunk Flags Requirement")]
        public ChunkFlags requiredFlags = ChunkFlags.None;

        /* ----------  HELPER FUNKTIOONID  ---------- */

        /// <summary>True = võib selles areas spawn’ida.</summary>
        public bool CanSpawnInArea(AreaData area)
        {
            if (allowedAreas == null || allowedAreas.Length == 0) return true;

            foreach (var a in allowedAreas)
                if (a == area) return true;

            return false;
        }

        /// <summary>Kontrollib, kas tüki flag’id sobivad.</summary>
        public bool CanSpawnWithFlags(ChunkFlags chunkFlags)
        {
            if (requiredFlags == ChunkFlags.None) return true;
            return (chunkFlags & requiredFlags) == requiredFlags;
        }
    }

    [Header("Available Structures")]
    public StructureEntry[] structures;

    public StructureEntry GetStructureEntry(int index)
    {
        if (structures == null || structures.Length == 0) return null;
        if (index >= 0 && index < structures.Length) return structures[index];

        Debug.LogWarning($"Structure index [{index}] is out of range.");
        return null;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\TileDatabase.cs
------------------------------
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "TileDatabase", menuName = "Game/Database/new Tile Database")]
public class TileDatabase : ScriptableObject
{
    [Header("Tiles")]
    public TileData[] tiles;
    public TileData SkyAirTile;
    public TileData UndergroundAirTile;
    public TileData PointOfIntrestTile;

    /// <summary>
    /// Retrieves TileData by the array index in 'tiles'.
    /// </summary>
    public TileData GetTileDataByIndex(int index)
    {
        if (index >= 0 && index < tiles.Length)
            return tiles[index];

        Debug.LogWarning($"Tile index [{index}] is out of range.");
        return null;
    }

    /// <summary>
    /// Retrieves TileData by its tileID (unique integer).
    /// </summary>
    public TileData GetTileDataByID(int tileID)
    {
        for (int i = 0; i < tiles.Length; i++)
        {
            if (tiles[i].tileID == tileID)
                return tiles[i];
        }
        Debug.LogWarning($"Requested tileID [{tileID}] not found in the database.");
        return null;
    }

    /// <summary>
    /// Retrieves TileData by matching the 'name' field of the TileData asset.
    /// If no match is found, returns null.
    /// </summary>
    public TileData GetTileDataByName(string tileName)
    {
        for (int i = 0; i < tiles.Length; i++)
        {
            // Compare the asset's 'name' or any custom name property you store
            if (tiles[i].name == tileName)
            {
                return tiles[i];
            }
        }

        Debug.LogWarning($"Tile with name [{tileName}] not found in the database.");
        return null;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Database\Databases\UnitDatabase.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Editor\DatabasePopulator.cs
------------------------------
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public static class DatabasePopulator
{
    /* ---------------------------  MENU ITEM  --------------------------- */
    [MenuItem("Assets/Populate Databases From Selection", priority = 1500)]
    private static void Populate()
    {
        // 1) Validate selection
        if (!TryGetSelection(out string folderPath,
                             out AreasDatabase areasDB,
                             out BiomeDatabase  biomeDB)) return;

        // 2) Gather AreaData assets inside the folder
        var areaGuids = AssetDatabase.FindAssets("t:AreaData", new[] { folderPath });
        var areaList  = new List<AreaData>();
        foreach (string g in areaGuids)
        {
            var a = AssetDatabase.LoadAssetAtPath<AreaData>(
                        AssetDatabase.GUIDToAssetPath(g));
            if (a != null && !areaList.Contains(a)) areaList.Add(a);
        }

        // 3) Gather BiomeData (direct + referenced)
        var biomeSet = new HashSet<BiomeData>();

        // 3a – direct BiomeData files in the folder
        var biomeGuids = AssetDatabase.FindAssets("t:BiomeData", new[] { folderPath });
        foreach (string g in biomeGuids)
        {
            var b = AssetDatabase.LoadAssetAtPath<BiomeData>(
                        AssetDatabase.GUIDToAssetPath(g));
            if (b != null) biomeSet.Add(b);
        }

        // 3b – biomes referenced by every AreaData
        foreach (var a in areaList)
            if (a != null && a.biomes != null)
                foreach (var b in a.biomes)
                    if (b != null) biomeSet.Add(b);

        // 4) Write back to databases
        areasDB.areas   = areaList.ToArray();
        biomeDB.biomelist = biomeSet.ToArray();

        EditorUtility.SetDirty(areasDB);
        EditorUtility.SetDirty(biomeDB);
        AssetDatabase.SaveAssets();

        Debug.Log($"[DatabasePopulator] Updated '{areasDB.name}' with {areasDB.areas.Length} areas " +
                  $"and '{biomeDB.name}' with {biomeDB.biomelist.Length} biomes.");
    }

    /* ----------------------  Validation helpers  ---------------------- */
    [MenuItem("Assets/Populate Databases From Selection", true)]
    private static bool ValidatePopulate()
    {
        return TryGetSelection(out _, out _, out _);
    }

    private static bool TryGetSelection(
        out string folderPath,
        out AreasDatabase areasDB,
        out BiomeDatabase biomeDB)
    {
        folderPath = null;
        areasDB    = null;
        biomeDB    = null;

        var sel = Selection.objects;

        if (sel.Length < 3) return false;

        foreach (var obj in sel)
        {
            if (obj is AreasDatabase ad) areasDB = ad;
            else if (obj is BiomeDatabase bd) biomeDB = bd;
            else if (AssetDatabase.IsValidFolder(AssetDatabase.GetAssetPath(obj)))
                folderPath = AssetDatabase.GetAssetPath(obj);
        }

        bool ok = folderPath != null && areasDB != null && biomeDB != null;
        if (!ok && !Selection.activeObject)  // show dialog only on actual attempt
            Debug.LogWarning(
                "Select ONE folder + ONE AreasDatabase + ONE BiomeDatabase, " +
                "then use 'Populate Databases From Selection'.");
        return ok;
    }
}
#endif
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Editor\ExtendedRuleTile.cs
------------------------------
using UnityEngine;
using UnityEngine.Tilemaps;

[CreateAssetMenu(fileName = "TileData_", menuName = "2D/Tiles/Extended Rule Tile")]
public class ExtendedRuleTile : RuleTile
{

    public string type;
    public override bool RuleMatch(int neighbor, TileBase other)
    {
        if (other is RuleOverrideTile)
            other = (other as RuleOverrideTile).m_InstanceTile;
      
        ExtendedRuleTile otherTile = other as ExtendedRuleTile;
      
        if (otherTile == null)
            return base.RuleMatch(neighbor, other);

        switch (neighbor)
        {
            case TilingRule.Neighbor.This: return type == otherTile.type ;
            case TilingRule.Neighbor.NotThis: return type != otherTile.type;
        }
        return true;

    }
}.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Editor\ExtendedRuleTileCloner.cs
------------------------------
// Editor/CloneExtendedRuleTile.cs
using UnityEditor;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public class CloneExtendedRuleTile : EditorWindow
{
    ExtendedRuleTile sourceTile;
    Texture2D        newSpriteSheet;

    /* ───────────────────────── menu entry ───────────────────────── */
    [MenuItem("Assets/Clone ExtendedRuleTile w/ new sprites", false, 2000)]
    static void Open() => GetWindow<CloneExtendedRuleTile>("Clone ExtendedRuleTile");

    /* ───────────────────────── Window UI ────────────────────────── */
    void OnGUI()
    {
        GUILayout.Label("1. Source ExtendedRuleTile (with rules to copy):", EditorStyles.boldLabel);
        sourceTile = (ExtendedRuleTile)EditorGUILayout.ObjectField(sourceTile, typeof(ExtendedRuleTile), false);

        GUILayout.Space(6);
        GUILayout.Label("2. Texture2D that contains the NEW sprites:", EditorStyles.boldLabel);
        newSpriteSheet = (Texture2D)EditorGUILayout.ObjectField(newSpriteSheet, typeof(Texture2D), false);

        GUI.enabled = sourceTile && newSpriteSheet;
        if (GUILayout.Button("Clone ▶ ExtendedRuleTile"))
            Clone();
        GUI.enabled = true;
    }

    /* ─────────────────────────  CORE  ───────────────────────────── */
    void Clone()
    {
        if (sourceTile == null || newSpriteSheet == null) return;

        /* folder & name -------------------------------------------------- */
        string targetDir   = Path.GetDirectoryName(AssetDatabase.GetAssetPath(newSpriteSheet));

        string matSuffix   = newSpriteSheet.name;          // "tiles_o_coal"
        if (matSuffix.StartsWith("tiles_"))
            matSuffix = matSuffix.Substring("tiles_".Length);
        string cloneName   = $"TileData_{matSuffix}";
        string clonePath   = AssetDatabase.GenerateUniqueAssetPath(
                                 Path.Combine(targetDir, cloneName + ".asset"));

        /* duplicate the ExtendedRuleTile -------------------------------- */
        var tileClone = Instantiate(sourceTile);
        AssetDatabase.CreateAsset(tileClone, clonePath);

        /* ---------- build lookup tables by numeric suffix -------------- */
        // a) sprites from NEW sheet
        var newSprites = AssetDatabase.LoadAllAssetsAtPath(AssetDatabase.GetAssetPath(newSpriteSheet))
                                      .OfType<Sprite>()
                                      .ToDictionary(GetNumericSuffixSafe, s => s);

        // b) sprites from ORIGINAL sheet (needed for default sprite mapping)
        Sprite firstSrc = FindFirstRuleSprite(sourceTile);
        if (firstSrc == null)
        {
            Abort("Source rule-tile has no sprites.", clonePath);
            return;
        }
        var srcSprites = AssetDatabase.LoadAllAssetsAtPath(AssetDatabase.GetAssetPath(firstSrc))
                                      .OfType<Sprite>()
                                      .ToDictionary(GetNumericSuffixSafe, s => s);

        /* ---------- swap sprites, suffix-by-suffix ---------------------- */
        foreach (var rule in tileClone.m_TilingRules)
        {
            for (int i = 0; i < rule.m_Sprites.Length; i++)
            {
                Sprite oldSprite = rule.m_Sprites[i];
                if (!oldSprite) continue;

                string id = GetNumericSuffixSafe(oldSprite);
                if (id != null && newSprites.TryGetValue(id, out Sprite replacement))
                    rule.m_Sprites[i] = replacement;
            }
        }

        /* also map default sprite -------------------------------------- */
        if (tileClone.m_DefaultSprite)
        {
            string id = GetNumericSuffixSafe(tileClone.m_DefaultSprite);
            if (id != null && newSprites.TryGetValue(id, out Sprite replacement))
                tileClone.m_DefaultSprite = replacement;
        }

        /* save & ping --------------------------------------------------- */
        EditorUtility.SetDirty(tileClone);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        Selection.activeObject = tileClone;

        EditorUtility.DisplayDialog("Clone created",
            $"New ExtendedRuleTile:\n• {Path.GetFileName(clonePath)}", "Great!");
    }

    /* ─────────────────── helpers ─────────────────── */
    static Sprite FindFirstRuleSprite(ExtendedRuleTile t)
    {
        foreach (var r in t.m_TilingRules)
            if (r.m_Sprites != null && r.m_Sprites.Length > 0 && r.m_Sprites[0])
                return r.m_Sprites[0];
        return null;
    }

    // returns the trailing digits (e.g. "_32") or null if none
    static string GetNumericSuffixSafe(Object obj)
    {
        if (obj == null) return null;
        var m = Regex.Match(obj.name, @"_(\d+)$");
        return m.Success ? m.Groups[1].Value : null;
    }

    void Abort(string msg, string pathToDelete)
    {
        EditorUtility.DisplayDialog("Clone ExtendedRuleTile", msg, "OK");
        if (!string.IsNullOrEmpty(pathToDelete))
            AssetDatabase.DeleteAsset(pathToDelete);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Editor\TileCreator.cs
------------------------------
using UnityEngine;
using UnityEditor;
using System.Linq;
using System.IO;

public static class TileCreator
{
    private const string DefaultTileFolder = "Assets"; // Where new tiles go if no folder is selected

    [MenuItem("Assets/Create/New Tile", priority = 1)]
    private static void CreateNewTile_AssetsMenu()
    {
        // Try to get a TileDatabase from the current selection or look up in the project
        TileDatabase db = TryGetSelectedTileDatabase() ?? FindAnyTileDatabase();
        if (db == null)
        {
            Debug.LogWarning("No TileDatabase selected or found. Tile creation canceled.");
            return;
        }

        // Get the path of whatever is selected in the Project window
        string folderPath = AssetDatabase.GetAssetPath(Selection.activeObject);
        if (string.IsNullOrEmpty(folderPath))
        {
            // If user hasn't selected anything, place the new file under DefaultTileFolder
            folderPath = DefaultTileFolder;
        }
        else if (!AssetDatabase.IsValidFolder(folderPath))
        {
            // If user selected a file instead of a folder, get its parent folder
            folderPath = Path.GetDirectoryName(folderPath);
        }

        CreateNewTile(db, folderPath);
    }

    private static void CreateNewTile(TileDatabase tileDb, string folderPath)
    {
        // Determine next available tileID
        int nextID = 0;
        foreach (var existing in tileDb.tiles)
        {
            nextID = Mathf.Max(nextID, existing.tileID + 1);
        }

        // Create the TileData asset in memory
        TileData newTile = ScriptableObject.CreateInstance<TileData>();
        newTile.tileID = nextID;
        newTile.name = "Tile_" + nextID;
        newTile.tileName = "New Tile " + nextID;

        // Generate unique path
        string assetPath = AssetDatabase.GenerateUniqueAssetPath(
            Path.Combine(folderPath, newTile.name + ".asset")
        );

        // Create the asset on disk
        AssetDatabase.CreateAsset(newTile, assetPath);
        AssetDatabase.SaveAssets();

        // Append it to the TileDatabase array
        var tileList = tileDb.tiles.ToList();
        tileList.Add(newTile);
        tileDb.tiles = tileList.ToArray();

        // Mark the TileDatabase as dirty so changes persist
        EditorUtility.SetDirty(tileDb);
        AssetDatabase.SaveAssets();

        Debug.Log($"Created new TileData: '{assetPath}' with tileID={nextID}. Added to {tileDb.name}.");
    }

    private static TileDatabase TryGetSelectedTileDatabase()
    {
        // If the user selected a TileDatabase, return it
        if (Selection.activeObject is TileDatabase db)
            return db;
        return null;
    }

    private static TileDatabase FindAnyTileDatabase()
    {
        // Look for any TileDatabase in the entire project
        string[] guids = AssetDatabase.FindAssets("t:TileDatabase");
        if (guids.Length > 0)
        {
            string path = AssetDatabase.GUIDToAssetPath(guids[0]);
            return AssetDatabase.LoadAssetAtPath<TileDatabase>(path);
        }
        return null;
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Editor\TileDatabaseEditor.cs
------------------------------
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;

/*───────────────────────────────────────────────────────────────────────────
 *  TileDatabaseEditor – one-click “Sort & Fix IDs” button
 *───────────────────────────────────────────────────────────────────────── */
[CustomEditor(typeof(TileDatabase))]
public class TileDatabaseEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        GUILayout.Space(6);

        if (GUILayout.Button("Sort & Fix Tile IDs", GUILayout.Height(28)))
        {
            var db = (TileDatabase)target;

            /* 1 ▸ warn if duplicates exist (but do NOT bail out) */
            var dups = FindDuplicateIDs(db);
            if (dups.Count > 0)
                Debug.LogWarning(
                    $"[TileDatabase] Duplicate tileIDs detected ({string.Join(", ", dups)}). " +
                    "They will be auto-fixed by re-indexing.");

            /* 2 ▸ normalise list → sort → assign sequential IDs */
            SortTilesAndAssignIDs(db);

            /* 3 ▸ flag asset dirty & save */
            EditorUtility.SetDirty(db);
            AssetDatabase.SaveAssets();

            Debug.Log("[TileDatabase] Tiles sorted and IDs synchronised.");
        }
    }

    /* ──────────────────────────────────────────────────────────────── */
    /*  core logic                                                     */
    /* ──────────────────────────────────────────────────────────────── */
    private static void SortTilesAndAssignIDs(TileDatabase db)
    {
        /* gather non-null tiles, remove duplicates of the *same* ScriptableObject */
        var tiles = db.tiles?.Where(t => t != null).Distinct().ToList()
                   ?? new List<TileData>();

        /* pull special tiles out so we can reserve indices 0 / 1 */
        tiles.Remove(db.SkyAirTile);
        tiles.Remove(db.UndergroundAirTile);

        /* alphabetical sort by name (or any key you prefer) */
        tiles = tiles.OrderBy(t => t.tileName).ToList();

        /* re-insert specials at the top (if assigned) */
        if (db.SkyAirTile         != null) tiles.Insert(0, db.SkyAirTile);
        if (db.UndergroundAirTile != null) tiles.Insert(1, db.UndergroundAirTile);

        /* assign sequential IDs that exactly match the new array order */
        for (int i = 0; i < tiles.Count; i++)
            tiles[i].tileID = i;

        db.tiles = tiles.ToArray();
    }

    /* quick duplicate scanner – returns duplicate IDs (if any) */
    private static List<int> FindDuplicateIDs(TileDatabase db)
    {
        var dup = new List<int>();
        var seen = new HashSet<int>();

        foreach (var t in db.tiles)
            if (t != null && !seen.Add(t.tileID))
                dup.Add(t.tileID);

        return dup;
    }
}
#endif
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Entity.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Projectiles\Projectile.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Projectiles\ProjectileCrazy.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Projectiles\ProjectileExplosive.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Projectiles\ProjectilePiercing.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Units\AISlime.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Units\AIZombie.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Entities\Units\Unit.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Inventory\Inventory.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\Inventory\Item.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\BiomeMapGenerator.cs
------------------------------
using UnityEngine;
using System.Collections;
using System.Diagnostics;                   // Stopwatch
using System;
using System.Collections.Generic;

/// <summary>
/// Generates area & biome maps and writes them into World chunks.
/// • Overworld  – picked by heat only (left‑hot ↔ right‑cold)  
/// • Sky & Underworld – picked by depth band AND nearest heat
/// </summary>
public static class BiomeMapGenerator
{
    /* ────────────────────  CACHES  ──────────────────── */
    static Dictionary<AreaData, (int min, int max, int width)> areaXRangeCache;
    static Dictionary<AreaData, BiomeData[]>                   shuffledBiomes;

    /* ────────────────────  ENTRY  ──────────────────── */
    public static IEnumerator GenerateFullMapAsync(
        World world, WorldData data, Action<World> onComplete)
    {
        var sw = new Stopwatch(); sw.Start();

        /* 1) Voronoi area map (low‑res) */
        byte[,] areaLow = GenerateAreaMap(
            data, data.areaGenerationSize.x, data.areaGenerationSize.y);

        /* 2) Stretch to elevation resolution */
        byte[,] areaHi = StretchMap(
            areaLow,
            data.areaGenerationSize.x, data.areaGenerationSize.y,
            data.elevationGenerationSize.x, data.elevationGenerationSize.y);

        /* 3) Elevation map */
        float[,] elev = GenerateElevationMap(
            data, data.elevationGenerationSize.x, data.elevationGenerationSize.y);

        /* 4) Area + elevation ⇒ biome map */
        byte[,] biomeHi = GenerateBiomeMap(data, areaHi, elev);

        /* 5) Stretch / warp to world size & fill chunks */
        int finalW = data.widthInChunks * data.chunkSize;
        int finalH = data.heightInChunks * data.chunkSize;

        StretchAreaAndBiomeWithEdgeNoiseAndFillChunks(
            world, data,
            areaHi, biomeHi,
            data.elevationGenerationSize.x, data.elevationGenerationSize.y,
            finalW, finalH);

        sw.Stop();
        UnityEngine.Debug.Log($"Full biome map generated in {sw.ElapsedMilliseconds} ms");
        yield return null;
        onComplete?.Invoke(world);
    }

    /* ────────────────── AREA MAP (Voronoi) ────────────────── */
    static byte[,] GenerateAreaMap(WorldData data, int w, int h)
    {
        if (data.areasDatabase?.areas == null || data.areasDatabase.areas.Length == 0)
            return new byte[w, h];

        var rng = new System.Random(data.seed);

        int ptsSU    = data.areaPointsCount;
        int owStrips = data.areaOverworldStripes;

        List<Vector2> centres = new();
        List<byte>    areaIDs = new();

        float owTopNorm    = data.overworldStarts;
        float owBottomNorm = data.overworldStarts - data.overworldDepth;

        /* A) random points for SKY + UNDERWORLD */
        for (int i = 0; i < ptsSU; i++)
        {
            float nY  = (float)rng.NextDouble();
            float xPx = (float)rng.NextDouble() * w;
            float yPx = nY * h;

            ZoneType zone = nY > owTopNorm
                            ? ZoneType.Sky
                            : (nY < owBottomNorm ? ZoneType.Underworld
                                                 : ZoneType.Overworld);

            if (zone == ZoneType.Overworld) continue;   // OW handled below

            float heatTarget = 1f - 2f * (xPx / w);     // +1 hot‑left → −1 cold‑right
            int idx = PickDepthHeatArea(data.areasDatabase, zone, nY, heatTarget, rng);

            centres.Add(new Vector2(xPx, yPx));
            areaIDs.Add((byte)idx);
        }

        /* B) Overworld stripe centres chosen by heat */
        float midY = (owTopNorm + owBottomNorm) * 0.5f * h;

        for (int s = 0; s < owStrips; s++)
        {
            float fracX = owStrips == 1 ? 0.5f : (float)s / (owStrips - 1);
            float xPx   = fracX * w;
            float heat  = 1f - 2f * fracX;

            int idx = PickAreaByHeat(data.areasDatabase, heat, rng);

            centres.Add(new Vector2(xPx, midY));
            areaIDs.Add((byte)idx);
        }

        /* C) Voronoi raster fill */
        byte[,] map = new byte[w, h];
        int total   = centres.Count;

        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
            {
                float best = float.MaxValue; int bestI = 0;
                for (int i = 0; i < total; i++)
                {
                    float dx = x - centres[i].x;
                    float dy = y - centres[i].y;
                    float d2 = dx * dx + dy * dy;
                    if (d2 < best) { best = d2; bestI = i; }
                }
                map[x, y] = areaIDs[bestI];
            }
        return map;
    }

    /* ────────────────── ELEVATION MAP ────────────────── */
    static float[,] GenerateElevationMap(WorldData data, int w, int h)
    {
        float[,] m = new float[w, h];
        float s = data.elevationNoiseScale, k = data.elevationNoiseIntensity;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
                m[x, y] = Mathf.PerlinNoise(x * s, y * s) * k;
        return m;
    }

    /* ────────────────── BIOME MAP (elev‑res) ────────────────── */
    static byte[,] GenerateBiomeMap(
        WorldData data, byte[,] areaMap, float[,] elevMap)
    {
        int w = areaMap.GetLength(0), h = areaMap.GetLength(1);

        AreaData[] areas = data.areasDatabase.areas;
        areaXRangeCache  = BuildAreaXRanges(areaMap, areas);  // named tuple cache
        shuffledBiomes   = new();

        byte[,] result = new byte[w, h];
        var globalDB   = data.biomeDatabase;

        for (int y = 0; y < h; y++)
        for (int x = 0; x < w; x++)
        {
            AreaData area = areas[areaMap[x, y]];
            BiomeData biome = area.zone == ZoneType.Overworld
                              ? PickOverworldBiomeByX(area, x)
                              : PickBiomeByElevation(area, elevMap[x, y]);

            int idx = (biome != null && globalDB?.biomelist != null)
                      ? Array.IndexOf(globalDB.biomelist, biome)
                      : 0;
            result[x, y] = (byte)Mathf.Clamp(idx, 0, 255);
        }
        return result;
    }

    /* ────────────────── BUILD X‑RANGES (named tuple) ────────────────── */
    static Dictionary<AreaData, (int min, int max, int width)> BuildAreaXRanges(
        byte[,] areaMap, AreaData[] areas)
    {
        int w = areaMap.GetLength(0), h = areaMap.GetLength(1);
        var dict = new Dictionary<AreaData, (int min, int max, int width)>();

        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++)
            {
                AreaData a = areas[areaMap[x, y]];
                if (a.zone != ZoneType.Overworld) continue;

                if (!dict.TryGetValue(a, out var span))
                    dict[a] = (min: x, max: x, width: 1);          // ← names here
                else
                {
                    if (x < span.min) span.min = x;
                    if (x > span.max) span.max = x;
                    span.width = span.max - span.min + 1;
                    dict[a] = span;
                }
            }
        return dict;
    }

    /* ────────────────── OVERWORLD BIOME PICKER ────────────────── */
    static BiomeData PickOverworldBiomeByX(AreaData area, int worldX)
    {
        if (area.biomes == null || area.biomes.Length == 0) return null;
        if (!areaXRangeCache.TryGetValue(area, out var span)) return area.biomes[0];

        int n = area.biomes.Length, width = span.width;
        if (width < n) return area.biomes[(worldX - span.min) % n];

        if (!shuffledBiomes.TryGetValue(area, out var order))
        {
            order = (BiomeData[])area.biomes.Clone();
            var rng = new System.Random(area.name.GetHashCode());
            for (int i = order.Length - 1; i > 0; i--)
            {
                int j = rng.Next(i + 1);
                (order[i], order[j]) = (order[j], order[i]);
            }
            shuffledBiomes[area] = order;
        }

        int localX   = worldX - span.min;
        float sliceW = (float)width / n;
        int slice    = Mathf.Clamp((int)(localX / sliceW), 0, n - 1);
        return order[slice];
    }

    /* ────────────────── SKY / UW BIOME PICKER (elev‑closest) ────────────────── */
    static BiomeData PickBiomeByElevation(AreaData area, float e)
    {
        if (area.biomes == null || area.biomes.Length == 0) return null;
        BiomeData best = area.biomes[0];
        float     dMin = Mathf.Abs(e - best.elevation);

        foreach (var b in area.biomes)
        {
            float d = Mathf.Abs(e - b.elevation);
            if (d < dMin) { dMin = d; best = b; }
        }
        return best;
    }

    /* ────────────────── STRETCH + EDGE‑NOISE + CHUNK FILL ────────────────── */
    static void StretchAreaAndBiomeWithEdgeNoiseAndFillChunks(
        World world, WorldData data,
        byte[,] areaSrc, byte[,] biomeSrc,
        int oldW, int oldH, int newW, int newH)
    {
        float sx = (float)oldW / newW, sy = (float)oldH / newH;
        float nS = data.edgeNoiseScale, nI = data.edgeNoiseIntensity;

        for (int y = 0; y < newH; y++)
        for (int x = 0; x < newW; x++)
        {
            float noise = Mathf.PerlinNoise(x * nS, y * nS);
            float shift = (noise - 0.5f) * nI;

            int sxIdx = Mathf.Clamp(Mathf.FloorToInt((x + shift) * sx), 0, oldW - 1);
            int syIdx = Mathf.Clamp(Mathf.FloorToInt((y + shift) * sy), 0, oldH - 1);

            byte aVal = areaSrc [sxIdx, syIdx];
            byte bVal = biomeSrc[sxIdx, syIdx];

            int cX = x / world.Data.chunkSize, cY = y / world.Data.chunkSize;
            Vector2Int coord = new(cX, cY);
            var chunk = world.GetChunk(coord) ?? world.AddChunk(coord);

            int lx = x % world.Data.chunkSize, ly = y % world.Data.chunkSize;
            chunk.areaIDs [lx, ly] = aVal;
            chunk.biomeIDs[lx, ly] = bVal;
            chunk.AddAreaID (aVal);
            chunk.AddBiomeID(bVal);
        }
    }

    /* ────────────────── SIMPLE NEAREST‑NEIGHBOUR STRETCH ────────────────── */
    static byte[,] StretchMap(byte[,] src, int oldW, int oldH, int newW, int newH)
    {
        byte[,] r = new byte[newW, newH];
        float sx = (float)oldW / newW, sy = (float)oldH / newH;

        for (int y = 0; y < newH; y++)
        for (int x = 0; x < newW; x++)
            r[x, y] = src[
                Mathf.Clamp(Mathf.FloorToInt(x * sx), 0, oldW - 1),
                Mathf.Clamp(Mathf.FloorToInt(y * sy), 0, oldH - 1)];
        return r;
    }

    /* ────────────────── DEPTH + HEAT AREA PICKER ────────────────── */
    // Chooses an area whose depth band contains normY **AND**
// whose heat band is closest to targetHeat.
// Overworld still uses single heat value.
static int PickDepthHeatArea(
    AreasDatabase db, ZoneType zone,
    float normY, float targetHeat, System.Random rng)
{
    float best = float.MaxValue;
    List<int> ties = new();

    for (int i = 0; i < db.areas.Length; i++)
    {
        AreaData a = db.areas[i];
        if (a.zone != zone) continue;

        float diff;

        switch (zone)
        {
            case ZoneType.Overworld:
                diff = Mathf.Abs(((AreaOverworldData)a).heat - targetHeat);
                break;

            case ZoneType.Sky:
            {
                var sw = (AreaSkyworldData)a;
                if (normY < sw.minDepth || normY > sw.maxDepth) continue;

                // distance to heat interval (0 if inside)
                diff = targetHeat < sw.minHeat ? sw.minHeat - targetHeat
                     : targetHeat > sw.maxHeat ? targetHeat - sw.maxHeat
                     : 0f;
                break;
            }

            case ZoneType.Underworld:
            {
                var uw = (AreaUnderworldData)a;
                if (normY < uw.minDepth || normY > uw.maxDepth) continue;

                diff = targetHeat < uw.minHeat ? uw.minHeat - targetHeat
                     : targetHeat > uw.maxHeat ? targetHeat - uw.maxHeat
                     : 0f;
                break;
            }

            default: continue;
        }

        if (diff < best - 1e-4f) { best = diff; ties.Clear(); ties.Add(i); }
        else if (Mathf.Abs(diff - best) < 1e-4f) ties.Add(i);
    }
    return ties.Count == 0 ? 0 : ties[rng.Next(ties.Count)];
}


    /* ────────────────── HEAT‑ONLY PICK (Overworld stripes) ────────────────── */
    static int PickAreaByHeat(AreasDatabase db, float target, System.Random rng)
    {
        float best = float.MaxValue; List<int> ties = new();

        for (int i = 0; i < db.areas.Length; i++)
            if (db.areas[i] is AreaOverworldData ow)
            {
                float diff = Mathf.Abs(ow.heat - target);
                if (diff < best - 1e-4f) { best = diff; ties.Clear(); ties.Add(i); }
                else if (Mathf.Abs(diff - best) < 1e-4f) ties.Add(i);
            }
        return ties.Count == 0 ? 0 : ties[rng.Next(ties.Count)];
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\LightingSystem.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;


public class LightingSystem : MonoBehaviour
{
   
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\MultiTargetCamera.cs
------------------------------
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Keeps *all* registered targets inside an orthographic view by
/// panning to their centroid and auto-zooming out as needed.
/// </summary>
[RequireComponent(typeof(Camera))]
public class MultiTargetCamera : MonoBehaviour
{
    [Header("Follow behaviour")]
    [SerializeField] float  lerpSpeed    = 5f;   // higher → snappier
    [SerializeField] float  minOrthoSize = 10f;  // never zoom closer than this
    [SerializeField] Vector3 offset      = new(0, 0, -10f);

    readonly List<Transform> targets = new();
    Camera   cam;
    Vector3  velocity;

    void Awake() => cam = GetComponent<Camera>();

    /* ─── Public API ─── */
    public void AddTarget(Transform t)
    {
        if (t && !targets.Contains(t))
            targets.Add(t);
    }
    public void RemoveTarget(Transform t) => targets.Remove(t);

    /* ─── Main loop ─── */
    void LateUpdate()
    {
        if (targets.Count == 0) return;

        // Remove any destroyed targets & compute centroid
        Vector3 centre = Vector3.zero;
        int live = 0;
        for (int i = targets.Count - 1; i >= 0; i--)
        {
            if (targets[i])
            {
                centre += targets[i].position;
                live++;
            }
            else targets.RemoveAt(i);
        }
        if (live == 0) return;
        centre /= live;

        // Smooth-move toward centre
        Vector3 goal = centre + offset;
        transform.position =
            Vector3.SmoothDamp(transform.position, goal, ref velocity, 1f / lerpSpeed);

        // Determine required half-extent to fit farthest target
        float maxDist = 0f;
        foreach (var t in targets)
            maxDist = Mathf.Max(maxDist, Vector2.Distance(centre, t.position));

        float desired = Mathf.Max(minOrthoSize, maxDist);
        cam.orthographicSize =
            Mathf.Lerp(cam.orthographicSize, desired, Time.deltaTime * lerpSpeed);
    }
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\World.cs
------------------------------

using UnityEngine;

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;

public enum TileLayer
{
    Front,
    Background
}

public struct PointOfInterest
{
    public Vector2Int position;
    public ChunkFlags poiFlags;
    
    public PointOfInterest(Vector2Int pos, ChunkFlags flags)
    {
        this.position = pos;
        this.poiFlags = flags;
    }
}

public class World
{
    /* ─────────────────────────  PUBLIC READ-ONLY  ───────────────────────── */
    public WorldData Data            { get; }      // original ScriptableObject
    public int   chunkSize           => Data.chunkSize;
    public int   widthInChunks       => Data.widthInChunks;
    public int   heightInChunks      => Data.heightInChunks;

    // convenient aliases
    public TileDatabase      tiles      => Data.tileDatabase;
    public AreasDatabase     areas      => Data.areasDatabase;
    public BiomeDatabase     biomes     => Data.biomeDatabase;
    public StructureDatabase structures => Data.structureDatabase;
    public OresDatabase      ores       => Data.oresDatabase;
    public int   seed                  => Data.seed;

    /* ─────────────────────────  RUNTIME STATE  ─────────────────────────── */
    private readonly Dictionary<Vector2Int, Chunk> chunks = new();
    private readonly List<PointOfInterest> pointsOfInterest = new();


    /* ─────────────────────────  CONSTRUCTOR  ───────────────────────────── */
    public World(WorldData data)
    {
        Data = data ?? throw new System.ArgumentNullException(nameof(data));
    }

    /* ─────────────────────────  CHUNK HELPERS  ─────────────────────────── */
    public Chunk GetChunk(Vector2Int coord) =>
        chunks.TryGetValue(coord, out var c) ? c : null;

    public Chunk AddChunk(Vector2Int coord)
    {
        if (!chunks.TryGetValue(coord, out var chunk))
        {
            chunk = new Chunk(coord, chunkSize);
            chunks[coord] = chunk;
        }
        return chunk;
    }

    public void CreateAllChunks()
    {
        for (int cy = 0; cy < heightInChunks; cy++)
            for (int cx = 0; cx < widthInChunks; cx++)
                AddChunk(new Vector2Int(cx, cy));
    }

    /* ─────────────────────────  TILE ACCESS  ───────────────────────────── */
   // NEW overload ─ specify which layer
    public int GetTileID(int wx, int wy, bool isBackground = false)
    {
        if (!InBounds(wx, wy)) return -1;
        Chunk ch = GetChunkAndLocal(wx, wy, out int lx, out int ly);
        if (ch == null) return -1;

        return isBackground
            ? ch.backgroundLayerTileIndexes[lx, ly]   // BG / wall layer
            : ch.frontLayerTileIndexes[lx, ly];       // front / block layer
    }
    public void SetTileID(int wx, int wy, int tileID, bool isBackground = false)
    {
        if (!InBounds(wx, wy)) return;
        Chunk ch = GetChunkAndLocal(wx, wy, out int lx, out int ly);
        if (ch == null) return;

        if (isBackground)
            ch.backgroundLayerTileIndexes[lx, ly] = tileID;
        else
        {
            ch.frontLayerTileIndexes[lx, ly] = tileID;
            UpdateChunkFlags(ch, tileID);
        }
    }
    // ─────────────  BIOME & AREA ACCESSORS (drop inside World) ─────────────
public BiomeData GetBiome(int wx, int wy)
{
    if (!InBounds(wx, wy)) return null;

    Chunk ch = GetChunkAndLocal(wx, wy, out int lx, out int ly);
    return ch != null ? biomes.GetBiomeData(ch.biomeIDs[lx, ly]) : null;
}

public AreaData GetArea(int wx, int wy)
{
    if (!InBounds(wx, wy)) return null;

    Chunk ch = GetChunkAndLocal(wx, wy, out int lx, out int ly);
    return ch != null ? areas.GetAreaData(ch.areaIDs[lx, ly]) : null;
}
    /* ─────────────────────────  POI SUPPORT  ───────────────────────────── */
    public void AddPointOfInterest(PointOfInterest poi) => pointsOfInterest.Add(poi);
    public IReadOnlyList<PointOfInterest> GetPointsOfInterest() => pointsOfInterest;

    /* ─────────────────────────  INTERNAL UTIL  ─────────────────────────── */
    private bool InBounds(int wx, int wy) =>
        wx >= 0 && wy >= 0 &&
        wx < widthInChunks * chunkSize &&
        wy < heightInChunks * chunkSize;

    private Chunk GetChunkAndLocal(int wx, int wy, out int lx, out int ly)
    {
        int cx = wx / chunkSize, cy = wy / chunkSize;
        lx = wx % chunkSize; ly = wy % chunkSize;
        return GetChunk(new Vector2Int(cx, cy));
    }

    private void UpdateChunkFlags(Chunk ch, int tileID)
    {
        TileData td = tiles.GetTileDataByID(tileID);
        if (td == null) return;

        if (tiles.SkyAirTile          && tileID == tiles.SkyAirTile.tileID)  ch.AddFlags(ChunkFlags.Surface);
        if (tiles.UndergroundAirTile  && tileID == Data.tileDatabase.UndergroundAirTile.tileID) ch.AddFlags(ChunkFlags.Cave);
        if (td.behavior == BlockBehavior.Liquid) ch.AddFlags(ChunkFlags.Liquids);
    }
    // ──────────────────────  SEMANTIC HELPERS  ──────────────────────

    public bool IsUndergroundAir(int id)
    {
        var ua = tiles.UndergroundAirTile;
        return id > 0 && ua != null && id == ua.tileID;
    }

    public bool IsLiquid(int id)
    {
        TileData td = tiles.GetTileDataByID(id);
        return td != null && td.behavior == BlockBehavior.Liquid;
    }

}



[System.Flags]
public enum ChunkFlags
{
    None     = 0,
    Surface  = 1 << 0,
    Cave     = 1 << 1,
    Liquids  = 1 << 2
    // add more as needed
}

public class Chunk
{
    public readonly int size;
    public readonly Vector2Int position;

    // We keep these so we can store the tile IDs for front/back
    public readonly int[,] frontLayerTileIndexes;
    public readonly int[,] backgroundLayerTileIndexes;
    
    public readonly byte[,] biomeIDs;
    public readonly byte[,] areaIDs;
    // Instead of storing byte[,] for each tile's biome or area:
    // We'll store sets of unique biome & area IDs that appear in the chunk.
    private HashSet<byte> chunkBiomes = new HashSet<byte>();
    private HashSet<byte> chunkAreas  = new HashSet<byte>();

    // The classification flags
    private ChunkFlags flags = ChunkFlags.None;

    public Chunk(Vector2Int position, int size)
    {
        this.position = position;
        this.size = size;

        frontLayerTileIndexes = new int[size, size];
        backgroundLayerTileIndexes = new int[size, size];
        biomeIDs = new byte[size, size];
        areaIDs  = new byte[size, size];
    }

    public ChunkFlags GetFlags() => flags;
    public void SetFlags(ChunkFlags newFlags) => flags = newFlags;
    public void AddFlags(ChunkFlags f) => flags |= f;
    public void RemoveFlags(ChunkFlags f) => flags &= ~f;
    public bool HasFlags(ChunkFlags f) => (flags & f) == f;

    // Accessors for chunk-level biome & area sets
    public IEnumerable<byte> GetBiomeIDs() => chunkBiomes;
    public IEnumerable<byte> GetAreaIDs()  => chunkAreas;

    public void AddBiomeID(byte b) => chunkBiomes.Add(b);
    public void AddAreaID(byte a)  => chunkAreas.Add(a);

    public void ClearBiomeIDs() => chunkBiomes.Clear();
    public void ClearAreaIDs()  => chunkAreas.Clear();
}

.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\WorldHelper.cs
------------------------------
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\WorldMapGenerator.cs
------------------------------
/* =========================================================================
   WorldMapGenerator.cs  (fast-path version, 24-Apr-25)
   – world-scale mask, area-blend, local & global ores
   – NO ScriptableObject look-ups in hot loops
   – skyline & mask noise still per-tile (see step-2 guide to cache rows)
   =========================================================================*/
using UnityEngine;
using System.Runtime.CompilerServices;               // MethodImpl

public static class WorldMapGenerator
{
    /* ──────────────────────────  cached refs  ────────────────────────── */
    static BiomeData[] _biomes;
    static AreaData[]  _areas;
    static OreSetting[] _ores;

    /* ──────────  fast per-tile meta (built once at startup)  ─────────── */
    static bool[]    _isSolid, _isLiquid;            // tileID → bool
    static TileData[] _tileCache;                    // tileID → TileData

    static void BuildTileMeta(TileDatabase db)
    {
        int max = db.tiles.Length;                   // IDs == indices (after your sorter)
        _isSolid   = new bool[max];
        _isLiquid  = new bool[max];
        _tileCache = db.tiles;                       // cheap alias

        foreach (var t in db.tiles)
        {
            _isSolid [t.tileID] = t.behavior == BlockBehavior.Solid;
            _isLiquid[t.tileID] = t.behavior == BlockBehavior.Liquid;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsSolidFast(int id)  => id > 0 && _isSolid[id];

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsLiquidFast(int id) => id > 0 && _isLiquid[id];

    /* ────────────────────────  public entry  ─────────────────────────── */
    public static void GenerateWorldTiles(World world, WorldData data)
    {
        /* build meta tables once */
        if (_isSolid == null) BuildTileMeta(data.tileDatabase);

        _biomes = data.biomeDatabase?.biomelist;
        _areas  = data.areasDatabase?.areas;
        _ores   = data.oresDatabase ? data.oresDatabase.ores : null;

        int seed = data.seed;

        for (int cy = 0; cy < data.heightInChunks; ++cy)
        for (int cx = 0; cx < data.widthInChunks;  ++cx)
        {
            Vector2Int c = new(cx, cy);
            Chunk ck = world.GetChunk(c) ?? world.AddChunk(c);
            FillChunkTiles(ck, data, seed);
        }
    }



    /* ────────────────────────── Helpers ───────────────────────────── */

    // 1-D fractal Brownian motion (3 octaves, lacunarity 2, gain 0.5)
    static float FBM(float x)
    {
        float sum = 0f, amp = 1f, freq = 1f;
        for (int i = 0; i < 3; ++i)
        {
            sum += amp * (Mathf.PerlinNoise(x * freq, 0f) * 2f - 1f);
            freq *= 2f;
            amp  *= 0.5f;
        }
        return sum;
    }

    // Cheap ridge noise: inverted-V Perlin squared (sharp peaks only)
    static float Ridge(float x)
    {
        float n = Mathf.PerlinNoise(x, 0f);
        n = 2f * (0.5f - Mathf.Abs(0.5f - n));
        return n * n;
    }

    /* ────────────────────── Main tile filler ──────────────────────── */
public static void FillChunkTiles(Chunk chunk, WorldData d, int seed)
{
    /* ─── initialise ─────────────────────────────────────────── */
    chunk.SetFlags(ChunkFlags.None);
    int cs  = chunk.size;
    int wx0 = chunk.position.x * cs;
    int wy0 = chunk.position.y * cs;
    int mapH = d.heightInChunks * d.chunkSize;

    float baseSkyNorm = d.overworldStarts - d.overworldDepth * 0.5f;
    bool sky = false, ground = false, cave = false, liquid = false;
    bool useWorldMask = d.worldNoiseFrequency > 0f;

    // Clamp border width to avoid array overruns
    int smoothW = Mathf.Clamp(d.borderSmoothWidth, 0, cs - 1);

    /* ─── iterate tiles ───────────────────────────────────────── */
    for (int ly = 0; ly < cs; ++ly)
    {
        int wy = wy0 + ly;
        float nY = (float)wy / mapH;      // depth-norm (0 top, 1 bottom)

        for (int lx = 0; lx < cs; ++lx)
        {
            int wx = wx0 + lx;

            /* ─── area look-up & border blend factor ─────────── */
            byte areaIx = chunk.areaIDs[lx, ly];
            AreaOverworldData aMain = (areaIx < _areas?.Length)
                                      ? _areas[areaIx] as AreaOverworldData
                                      : null;

            float blendT = 0f;
            AreaOverworldData aBlend = null;

            // scan left
            if (lx > 0)
            {
                byte leftIx = chunk.areaIDs[lx - 1, ly];
                if (leftIx != areaIx)
                {
                    int dist = 0;
                    for (int dx = 1; dx <= smoothW && lx - dx >= 0; ++dx)
                    {
                        if (chunk.areaIDs[lx - dx, ly] == leftIx) dist++; else break;
                    }
                    aBlend = (leftIx < _areas?.Length)
                             ? _areas[leftIx] as AreaOverworldData : null;
                    blendT = 1f - (float)dist / (smoothW + 1);
                }
            }

            // scan right
            if (aBlend == null && lx < cs - 1)
            {
                byte rightIx = chunk.areaIDs[lx + 1, ly];
                if (rightIx != areaIx)
                {
                    int dist = 0;
                    for (int dx = 1; dx <= smoothW && lx + dx < cs; ++dx)
                    {
                        if (chunk.areaIDs[lx + dx, ly] == rightIx) dist++; else break;
                    }
                    aBlend = (rightIx < _areas?.Length)
                             ? _areas[rightIx] as AreaOverworldData : null;
                    blendT = (float)dist / (smoothW + 1);
                }
            }

            /* ─── skyline parameters ─────────────────────────── */
            // Global FBM + ridge noise
            float lowFreq   = d.skyLowFreq;
            float lowAmp    = d.skyLowAmp;
            float ridgeFreq = d.skyRidgeFreq;
            float ridgeAmp  = d.skyRidgeAmp;

            // Per-area cosine modifiers
            float cosMul = aMain ? aMain.skyCosAmpMul : 1f;
            float cosOff = aMain ? aMain.skyCosOffset : 0f;

            // Per-area ruggedness (-1 = neutral)
            float rugMain  = (aMain && aMain.skylineRuggedness >= 0f)
                             ? aMain.skylineRuggedness : 0.5f;
            float rugBlend = 0.5f;
            if (aBlend)
                rugBlend = (aBlend.skylineRuggedness >= 0f)
                           ? aBlend.skylineRuggedness : 0.5f;

            if (aBlend && blendT > 0f)
            {
                cosMul = Mathf.Lerp(cosMul, aBlend.skyCosAmpMul, blendT);
                cosOff = Mathf.Lerp(cosOff, aBlend.skyCosOffset, blendT);
                rugMain = Mathf.Lerp(rugMain, rugBlend, blendT);
            }

            // Map ruggedness 0…1 → amplitude multiplier 0.3…1.7
            float ampMul = Mathf.Lerp(0.3f, 1.7f, rugMain);
            lowAmp   *= ampMul;
            ridgeAmp *= ampMul;
            float mountainAmpLocal = d.skyMountainAmp * ampMul;

            /* ─── compute skyline height ─────────────────────── */
            float cosWave = Mathf.Cos((wx + seed) * d.skyLineWaveScale)
                          * 0.5f * d.skyLineWaveAmplitude;
            cosWave = cosWave * cosMul + cosOff;

            float fbm    = FBM((wx + seed) * lowFreq)     * lowAmp;
            float ridges = Ridge((wx + seed) * ridgeFreq) * ridgeAmp;

            // Mountain / valley mask
            float mNoise = Mathf.PerlinNoise((wx + seed) * d.skyMountainFreq,
                                             (wy + seed) * d.skyMountainFreq);
            float mountain = 0f;
            if (mNoise > 0.6f)          // mountain
            {
                float t = (mNoise - 0.6f) / 0.4f;          // 0…1
                mountain = t * t * mountainAmpLocal;
            }
            else if (mNoise < 0.3f)     // valley
            {
                float t = (0.3f - mNoise) / 0.3f;          // 0…1
                mountain = -t * t * mountainAmpLocal * d.skyValleyFactor;
            }

            float skyNorm = baseSkyNorm + cosWave + fbm + ridges + mountain;

            /* ─── biome / area look-ups ──────────────────────── */
            byte biomeIx = chunk.biomeIDs[lx, ly];
            BiomeData biome = (biomeIx < _biomes?.Length) ? _biomes[biomeIx] : null;
            AreaData  area  = aMain ?? ((areaIx < _areas?.Length) ? _areas[areaIx] : null);

            /* ─── world-scale mask ───────────────────────────── */
            bool frontMasked = false;
            if (useWorldMask && biome != null && biome.worldNoiseThreshold > 0f)
            {
                float m = Mathf.PerlinNoise((wx + seed) * d.worldNoiseFrequency,
                                            (wy + seed) * d.worldNoiseFrequency);
                if (m < biome.worldNoiseThreshold) frontMasked = true;
            }

            /* ─── area-scale blend noise ─────────────────────── */
            float blendNoise = biome?.areaNoiseBlend ?? 0f;
            float areaNoise  = 0f;
            if (blendNoise > 0f)
            {
                float areaFreq = area ? area.areaNoiseFrequency : 0.003f;
                areaNoise = Mathf.PerlinNoise((wx + seed) * areaFreq,
                                              (wy + seed) * areaFreq);
            }

            int front = -1, back = -1;

            /* ─── decide sky / ground ─────────────────────────── */
            bool isAboveSky = nY > skyNorm;
            bool biomeIsSky = area != null && area.zone == ZoneType.Sky;

            if (isAboveSky && !biomeIsSky)
            {
                front = back = SafeID(d.tileDatabase.SkyAirTile);
                sky = true;
            }
            else
            {
                float depthPx = Mathf.Max(0f, skyNorm * mapH - wy);
                bool usedLayer = biome is BiomeOverworldData ow &&
                                 ow.overworldLayers is { Length: >0 } &&
                                 TryPickOverworldLayer(
                                     ow, depthPx, wx, wy, seed,
                                     areaNoise, blendNoise, out front, out back);

                if (!usedLayer)
                {
                    front = PickFromBlock(biome?.FrontLayerTiles, biome,
                                          wx, wy, seed, areaNoise, blendNoise);
                    back  = PickFromBlock(biome?.BackgroundLayerTiles, biome,
                                          wx, wy, seed, areaNoise, blendNoise);
                }

                if (front < 0) front = SafeID(isAboveSky
                                              ? d.tileDatabase.SkyAirTile
                                              : d.tileDatabase.UndergroundAirTile);
                if (back  < 0) back  = 0;

                /* local ores */
                if (!frontMasked && IsSolidFast(front) &&
                    biome?.localOres is { Length: >0 })
                {
                    TryInjectLocalOre(ref front, biome.localOres, nY,
                                      wx, wy, seed, area, d);
                }

                if (isAboveSky) sky = true; else ground = true;
                if (!cave && !isAboveSky &&
                    (IsUGAir(front, d) || IsUGAir(back, d))) cave = true;
            }

            /* apply front mask */
            if (frontMasked)
                front = SafeID(d.tileDatabase.UndergroundAirTile);

            /* write tiles */
            chunk.frontLayerTileIndexes[lx, ly] = front;
            chunk.backgroundLayerTileIndexes[lx, ly] = back;
            if (!liquid &&
                (IsLiquidFast(front) || IsLiquidFast(back))) liquid = true;
        }
    }

    /* ─── set chunk flags ─────────────────────────────────────── */
    ChunkFlags cf = ChunkFlags.None;
    if (sky && ground) cf |= ChunkFlags.Surface;
    if (!sky && cave)  cf |= ChunkFlags.Cave;
    if (liquid)        cf |= ChunkFlags.Liquids;
    chunk.SetFlags(cf);
}



/// <summary>
/// Instead of dropping a sapling, pick a random BlueprintTree from the
/// biome and try to plant it directly if there's room.
/// </summary>
static void CheckAndPlantTrees(World world, Chunk chunk, WorldData data)
{
    int chunkSize = chunk.size;

    for (int localY = 0; localY < chunkSize; localY++)
    {
        for (int localX = 0; localX < chunkSize; localX++)
        {
            // 1. Ground tile at this location?
            int groundID = chunk.frontLayerTileIndexes[localX, localY];
            if (groundID <= 0) continue;

            // 2. Which biome is this tile in?
            byte biomeID = chunk.biomeIDs[localX, localY];
            if (biomeID >= data.biomeDatabase.biomelist.Length) continue;

            BiomeData biome = data.biomeDatabase.biomelist[biomeID];
            if (biome == null || biome.Trees == null || biome.Trees.Length == 0) continue;

            // 3. Probability gate
            if (Random.value > biome.treeSpawnChance) continue;

            // 4. Must have AIR directly above the ground
            int aboveY = localY + 1;
            if (aboveY >= chunkSize) continue;                        // top-of-chunk edge
            if (chunk.frontLayerTileIndexes[localX, aboveY] != 0) continue;

            // 5. Choose a tree blueprint
            BlueprintTree treeBP = biome.Trees[Random.Range(0, biome.Trees.Length)];
            if (treeBP == null) continue;

            // 6. Convert local → world coords once
            int worldX = chunk.position.x * chunk.size + localX;
            int worldY = chunk.position.y * chunk.size + localY;

            // 7. Anchor one tile *above* the ground (same rule the sapling system used)
            int anchorY = worldY + 1;

            // 8. Let the blueprint decide if it actually fits (HasFreeSpace test is inside)
            treeBP.PlaceStructure(world, worldX, anchorY);
        }
    }
}



    /* ------------------------------------------------------------------ */
    /*  overworld depth-layer helper                                      */
    /* ------------------------------------------------------------------ */
    static bool TryPickOverworldLayer(
        BiomeOverworldData ow, float depthPx,
        int wx,int wy,int seed,
        float areaNoise,float blend,
        out int front,out int back)
    {
        foreach (var L in ow.overworldLayers)
            if (depthPx >= L.minDepth && depthPx <= L.maxDepth)
            {
                front = PickFromSubTiles(L.FrontLayerTiles,
                                         ow.OverworldnoiseScale, ow.OverworldnoiseIntensity,
                                         wx, wy, seed,
                                         areaNoise, blend);

                back  = PickFromSubTiles(L.BackgroundLayerTiles,
                                         ow.OverworldnoiseScale, ow.OverworldnoiseIntensity,
                                         wx, wy, seed,
                                         areaNoise, blend);
                return true;
            }
        front = back = -1;
        return false;
    }

    /* ------------------------------------------------------------------ */
    /*  block & subtile pickers                                           */
    /* ------------------------------------------------------------------ */
    static int PickFromBlock(BiomeBlock blk,BiomeData biome,
                             int wx,int wy,int seed,
                             float areaNoise,float blend)
    {
        if (blk == null || blk.subTiles is not { Length: >0 }) return -1;

        float n = SampleBiomeNoise(biome, wx, wy, seed, blk.NoiseOffset,
                                   areaNoise, blend);
        return NearestThreshold(blk.subTiles, n);
    }

    static int PickFromSubTiles(BiomeSubTile[] subs,float scale,float intens,
                                int wx,int wy,int seed,
                                float areaNoise,float blend)
    {
        if (subs == null || subs.Length == 0) return -1;

        float nBiome = Mathf.PerlinNoise(wx*scale,(seed+wy)*scale)*intens;
        float n = blend > 0f ? Mathf.Lerp(nBiome, areaNoise, blend) : nBiome;
        return NearestThreshold(subs, n);
    }

    /* ------------------------------------------------------------------ */
    /*  local-ore injection                                               */
    /* ------------------------------------------------------------------ */
    static void TryInjectLocalOre(
        ref int front,
        OreSetting[] ores,
        float depthNorm,
        int wx, int wy, int seed,
        AreaData area,
        WorldData d)
    {
        if (!IsSolidFast(front) || ores == null || ores.Length == 0) return;

        TileData host = _tileCache[front];

        foreach (var o in ores)
        {
            if (!o.oreTile) continue;
            if (depthNorm < o.minDepthNorm || depthNorm > o.maxDepthNorm) continue;
            if (o.validHostTiles?.Count > 0 && !o.validHostTiles.Contains(host)) continue;

            float n = Mathf.PerlinNoise(
                        (wx + seed) * o.noiseFrequency,
                        (wy + seed) * o.noiseFrequency);

            if (n > o.threshold && Random.value < o.chance)
            {
                front = o.oreTile.tileID;
                return;
            }
        }
    }

    /* ------------------------------------------------------------------ */
    /*  closest-threshold (binary search)                                 */
    /* ------------------------------------------------------------------ */
    static int NearestThreshold(BiomeSubTile[] subs,float n)
    {
        int lo = 0, hi = subs.Length - 1;
        while (lo <= hi)
        {
            int mid = (lo + hi) >> 1;
            if (subs[mid].threshold < n) lo = mid + 1; else hi = mid - 1;
        }
        int low = Mathf.Clamp(hi, 0, subs.Length - 1);
        int up  = Mathf.Clamp(lo, 0, subs.Length - 1);
        int pick = Mathf.Abs(n - subs[low].threshold) <= Mathf.Abs(n - subs[up].threshold)
                   ? low : up;
        return subs[pick].tileData ? subs[pick].tileData.tileID : -1;
    }

    /* ------------------------------------------------------------------ */
    /*  FBm per-biome noise (plus optional blend)                         */
    /* ------------------------------------------------------------------ */
    static float SampleBiomeNoise(BiomeData b,int wx,int wy,int seed,Vector2 off,
                                  float areaNoise,float blend)
    {
        if (b == null) return areaNoise;

        float freq = b.frequency, amp = 1f, sum = 0f;
        for (int o = 0; o < b.octaves; ++o)
        {
            float nx = (wx + off.x + seed + b.offset.x) * freq * b.stretch.x;
            float ny = (wy + off.y + seed + b.offset.y) * freq * b.stretch.y;

            float n = Mathf.PerlinNoise(nx, ny);
            sum  += n * amp;
            freq *= b.lacunarity;
            amp  *= b.persistence;
        }
        float biomeN = Mathf.Clamp01(sum * b.strength);
        return blend > 0f ? Mathf.Lerp(biomeN, areaNoise, blend) : biomeN;
    }

    /* ------------------------------------------------------------------ */
    /*  tiny helpers                                                      */
    /* ------------------------------------------------------------------ */
    static int  SafeID(TileData td) => td ? td.tileID : 0;
    static bool IsUGAir(int id,WorldData d)=>
        id>0 && d.tileDatabase.UndergroundAirTile &&
        id==d.tileDatabase.UndergroundAirTile.tileID;
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\WorldMapPOIGenerator.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Generates Points‑of‑Interest (POIs) across the world and assigns structures to them.
/// Converted from biome‑based to area‑based.
/// </summary>
public static class WorldMapPOIGenerator
{
    // Keeps track of how many times a blueprint has spawned in this world.
    private static readonly Dictionary<BlueprintStructure, int> s_spawnCounts = new Dictionary<BlueprintStructure, int>();

    /// <summary>
    /// Places POIs in the world according to predefined grid rules and then
    /// assigns structures that are compatible with each POI's area and chunk flags.
    /// </summary>
    public static void PlaceAllPois(World world, WorldData data)
    {
        s_spawnCounts.Clear();

        // 1) Regular (and cave) POIs every 5 chunks
        for (int cy = 0; cy < world.Data.heightInChunks; cy++)
        {
            for (int cx = 0; cx < world.Data.widthInChunks; cx++)
            {
                Chunk chunk = world.GetChunk(new Vector2Int(cx, cy));
                if (chunk == null) continue;

                if (chunk.position.x % 5 == 0 && chunk.position.y % 5 == 0)
                {
                    if (chunk.HasFlags(ChunkFlags.Cave))
                        PlaceCavePoiInChunk(world, chunk, data);
                    else
                        PlaceSinglePoiInChunk(world, chunk, data);
                }
            }
        }

        // 2) Surface POIs every 4 chunks, requires Surface flag
        for (int cy = 0; cy < world.Data.heightInChunks; cy++)
        {
            for (int cx = 0; cx < world.Data.widthInChunks; cx++)
            {
                Chunk chunk = world.GetChunk(new Vector2Int(cx, cy));
                if (chunk == null) continue;

                if (chunk.HasFlags(ChunkFlags.Surface) &&
                    chunk.position.x % 4 == 0 && chunk.position.y % 4 == 0)
                {
                    PlaceSurfacePoiInChunk(world, chunk, data);
                }
            }
        }

        // 3) Assign structures to every generated POI
        AssignStructuresToPOIs(world, data);
    }

    #region POI placement helpers -----------------------------------------------------

    private static void PlaceSinglePoiInChunk(World world, Chunk chunk, WorldData data)
    {
        TileData poiTile = data.tileDatabase.PointOfIntrestTile;
        if (poiTile == null)
        {
            Debug.LogWarning("No 'PointOfInterest' tile found. Skipping POI placement.");
            return;
        }

        int localX = Random.Range(0, chunk.size);
        int localY = Random.Range(0, chunk.size);

        int worldX = chunk.position.x * chunk.size + localX;
        int worldY = chunk.position.y * chunk.size + localY;

        world.AddPointOfInterest(new PointOfInterest(new Vector2Int(worldX, worldY), chunk.GetFlags()));
    }

    private static void PlaceSurfacePoiInChunk(World world, Chunk chunk, WorldData data)
    {
        if (!chunk.HasFlags(ChunkFlags.Surface)) return;

        TileData poiTile = data.tileDatabase.PointOfIntrestTile;
        if (poiTile == null)
        {
            Debug.LogWarning("No 'PointOfInterest' tile found. Skipping surface POI placement.");
            return;
        }

        int chunkSize = chunk.size;
        int localX = Random.Range(0, chunkSize);

        // Find topmost solid tile in column
        for (int localY = chunkSize - 1; localY >= 0; localY--)
        {
            int tileID = chunk.frontLayerTileIndexes[localX, localY];
            if (!IsAirTile(data, tileID))
            {
                int yAbove = localY + 1;
                if (yAbove < chunkSize)
                {
                    chunk.frontLayerTileIndexes[localX, yAbove] = poiTile.tileID;

                    int worldX = chunk.position.x * chunk.size + localX;
                    int worldY = chunk.position.y * chunk.size + yAbove;

                    world.AddPointOfInterest(new PointOfInterest(new Vector2Int(worldX, worldY), chunk.GetFlags()));
                }
                return;
            }
        }
    }

    private static void PlaceCavePoiInChunk(World world, Chunk chunk, WorldData data)
    {
        if (data.tileDatabase.UndergroundAirTile == null)
        {
            Debug.LogWarning("No 'UndergroundAirTile' found. Skipping cave POI placement.");
            return;
        }

        int undergroundID = data.tileDatabase.UndergroundAirTile.tileID;

        for (int attempt = 0; attempt < 10; attempt++)
        {
            int localX = Random.Range(0, chunk.size);
            int localY = Random.Range(0, chunk.size);

            if (chunk.frontLayerTileIndexes[localX, localY] == undergroundID)
            {
                int worldX = chunk.position.x * chunk.size + localX;
                int worldY = chunk.position.y * chunk.size + localY;

                world.AddPointOfInterest(new PointOfInterest(new Vector2Int(worldX, worldY), chunk.GetFlags()));
                return;
            }
        }
    }

    #endregion

    #region Structure assignment -------------------------------------------------------

    private static void AssignStructuresToPOIs(World world, WorldData data)
    {
        if (data.structureDatabase == null ||
            data.structureDatabase.structures == null ||
            data.structureDatabase.structures.Length == 0)
        {
            Debug.LogWarning("No StructureDatabase found. Skipping structure assignment.");
            return;
        }

        var poiPositions = world.GetPointsOfInterest()?.Select(p => p.position).ToList();
        if (poiPositions == null || poiPositions.Count == 0) return;

        ShuffleList(poiPositions);

        foreach (Vector2Int pos in poiPositions)
        {
            Chunk chunk = WorldToChunk(world, pos.x, pos.y);
            if (chunk == null) continue;

            int localX = pos.x % chunk.size;
            int localY = pos.y % chunk.size;

            // 1) Determine the area at this POI
            AreaData currentArea = GetAreaAt(world, chunk, localX, localY, data);
            if (currentArea == null) continue;

            // 2) Pick a structure that can spawn in this area
            var entry = PickStructureForArea(data.structureDatabase, currentArea);
            if (entry == null) continue;

            // 3) Validate chunk flags
            if (!entry.CanSpawnWithFlags(chunk.GetFlags())) continue;

            // 4) Enforce per‑world spawn limit
            if (!s_spawnCounts.ContainsKey(entry.structureBlueprint))
                s_spawnCounts[entry.structureBlueprint] = 0;

            if (s_spawnCounts[entry.structureBlueprint] >= entry.maxSpawnsPerWorld)
                continue;

            // 5) Check tile / blueprint constraints
            int tileID = world.GetTileID(pos.x, pos.y);
            if (!entry.structureBlueprint.canBePlacedInAir &&
                data.tileDatabase.SkyAirTile != null &&
                tileID == data.tileDatabase.SkyAirTile.tileID)
            {
                continue;
            }

            // 6) Place the structure
            if (entry.structureBlueprint.CanPlaceStructure(world, pos.x, pos.y))
            {
                entry.structureBlueprint.PlaceStructure(world, pos.x, pos.y);
                s_spawnCounts[entry.structureBlueprint]++;
            }
        }
    }

    #endregion

    #region Utility --------------------------------------------------------------------

    private static StructureDatabase.StructureEntry PickStructureForArea(StructureDatabase db, AreaData area)
    {
        var suitable = new List<StructureDatabase.StructureEntry>();
        foreach (var e in db.structures)
        {
            if (e.structureBlueprint == null) continue;
            if (e.CanSpawnInArea(area)) suitable.Add(e);
        }
        if (suitable.Count == 0) return null;
        return suitable[Random.Range(0, suitable.Count)];
    }

    private static AreaData GetAreaAt(World world, Chunk chunk, int localX, int localY, WorldData data)
    {
        if (chunk == null) return null;

        byte areaID = chunk.areaIDs[localX, localY]; // requires areaIDs array on Chunk
        if (areaID >= data.areasDatabase.areas.Length) return null;
        return data.areasDatabase.areas[areaID];
    }

    private static bool IsAirTile(WorldData data, int tileID)
    {
        if (tileID <= 0) return true;
        if (data.tileDatabase.SkyAirTile != null && tileID == data.tileDatabase.SkyAirTile.tileID) return true;
        if (data.tileDatabase.UndergroundAirTile != null && tileID == data.tileDatabase.UndergroundAirTile.tileID) return true;
        return false;
    }

    private static void ShuffleList<T>(List<T> list)
    {
        for (int i = list.Count - 1; i > 0; i--)
        {
            int rand = Random.Range(0, i + 1);
            (list[i], list[rand]) = (list[rand], list[i]);
        }
    }

    private static Chunk WorldToChunk(World world, int worldX, int worldY)
    {
        if (worldX < 0 || worldY < 0 ||
            worldX >= world.Data.widthInChunks * world.Data.chunkSize ||
            worldY >= world.Data.heightInChunks * world.Data.chunkSize)
            return null;

        int cx = worldX / world.Data.chunkSize;
        int cy = worldY / world.Data.chunkSize;
        return world.GetChunk(new Vector2Int(cx, cy));
    }

    #endregion
}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\WorldMapPostGenerator.cs
------------------------------
using UnityEngine;
using System.Collections.Generic;
using System;

public static class WorldMapPostGenerator
{
    /// <summary>
    /// Entry point for post-processing the entire world.  
    /// Loops over all chunks and calls PostProcessChunk on each.
    /// </summary>
    public static void PostProcessWorld(World world, WorldData data)
    {
        for (int cy = 0; cy < world.Data.heightInChunks; cy++)
        {
            for (int cx = 0; cx < world.Data.widthInChunks; cx++)
            {
                Vector2Int chunkCoord = new Vector2Int(cx, cy);
                Chunk chunk = world.GetChunk(chunkCoord);
                if (chunk == null) 
                    continue;

                PostProcessChunk(world, chunk, data);
            }
        }
    }

    /// <summary>
    /// Performs all per-chunk finalization tasks: converting to grass, settling powders, etc.
    /// </summary>
    static void PostProcessChunk(World world, Chunk chunk, WorldData data)
    {
        int chunkSize = chunk.size;

        // Loop over every tile in this chunk
        for (int localY = 0; localY < chunkSize; localY++)
        {
            for (int localX = 0; localX < chunkSize; localX++)
            {
                // Grass conversion
                CheckAndConvertToGrass(world, chunk, data, localX, localY);

                // Powder settling
                CheckAndSettlePowder(world, chunk, data, localX, localY);

                // Liquid spreading
                CheckAndSpreadLiquid(world, chunk, data, localX, localY);

                // Vine growth
                CheckAndGrowVines(world, chunk, data, localX, localY);
            }
        }
        
       CheckAndPlantTrees(world, chunk, data);   // NEW
       CheckAndPlaceFoliage(world, chunk, data);   // NEW
    }

/// <summary>
/// Converts the current tile to its grass variant iff:
///   1. At least one neighbouring face is Sky-Air *or* Underground-Air, and
///   2. The enclosing Area’s ZoneType is Sky or Overworld.
/// Intended for the world-generation phase (one-shot pass).
/// </summary>
static void CheckAndConvertToGrass(
        World     world,
        Chunk     chunk,
        WorldData data,
        int       localX,
        int       localY)
{
    /* ───── Early outs ───── */
    int frontTileID = chunk.frontLayerTileIndexes[localX, localY];
    if (frontTileID <= 0) return;

    TileData placedTile = data.tileDatabase.GetTileDataByID(frontTileID);
    if (placedTile == null || placedTile.grassTile == null) return;

    /* ───── Area-zone gate ───── */
    int worldX = chunk.position.x * chunk.size + localX;
    int worldY = chunk.position.y * chunk.size + localY;

    AreaData area = world.GetArea(worldX, worldY);
    if (area == null) return;                                   // should not happen
    ZoneType z = area.zone;
    if (z != ZoneType.Sky && z != ZoneType.Overworld) return;   // grass not allowed here

    /* ───── Neighbour-air test ───── */
    int skyID  = data.tileDatabase.SkyAirTile?.tileID          ?? -1;
    int caveID = data.tileDatabase.UndergroundAirTile?.tileID ?? -1;

    //          up, left, right, down
    int[] dx = {  0,  -1,  1,   0 };
    int[] dy = {  1,   0,  0,  -1 };

    for (int i = 0; i < 4; i++)
    {
        int nx = worldX + dx[i];
        int ny = worldY + dy[i];

        int neighbour = world.GetTileID(nx, ny);   // safe across chunk borders

        if (neighbour == skyID || neighbour == caveID)
        {
            chunk.frontLayerTileIndexes[localX, localY] = placedTile.grassTile.tileID;
            break;      // converted – stop checking other faces
        }
    }
}



    /// <summary>
    /// Looks for powder tiles and tries to let them "settle" downward if there's space.
    /// </summary>
    static void CheckAndSettlePowder(World world, Chunk chunk, WorldData data, int localX, int localY)
    {
        int worldX = chunk.position.x * chunk.size + localX;
        int worldY = chunk.position.y * chunk.size + localY;
        int tileID = world.GetTileID(worldX, worldY);
        if (tileID <= 0) return;

        TileData tileData = data.tileDatabase.GetTileDataByID(tileID);
        if (tileData == null || tileData.behavior != BlockBehavior.Powder) 
            return;

        SettlePowderColumn(world, data, worldX, worldY);
    }
/// <summary>
/// Spawns decorative foliage tiles above surface blocks during world-gen.
/// ▸ Uses the biome’s foliageTiles catalogue and foliageSpawnChance.  
/// ▸ Places only if the cell above is empty (air).  
/// ▸ Respects each foliage tile’s canPlaceOnTiles whitelist:  
///     • If the list is empty → foliage is universal.  
///     • If the list has entries → ground tile must match one of them.  
/// </summary>
/// <summary>
/// Spawns decorative foliage tiles above surface blocks during world-gen.
/// • Uses the biome’s foliageTiles catalogue and foliageSpawnChance.  
/// • The overhead cell must be Sky-Air *or* Underground-Air (not just empty).  
/// • Respects each foliage tile’s canPlaceOnTiles whitelist.  
/// </summary>
static void CheckAndPlaceFoliage(World world, Chunk chunk, WorldData data)
{
    int chunkSize = chunk.size;
    int skyID  = data.tileDatabase.SkyAirTile?.tileID          ?? -1;
    int caveID = data.tileDatabase.UndergroundAirTile?.tileID ?? -1;

    for (int localY = 0; localY < chunkSize; localY++)
    {
        for (int localX = 0; localX < chunkSize; localX++)
        {
            /* 1 ▸ Surface block ------------------------------------------------ */
            int groundID = chunk.frontLayerTileIndexes[localX, localY];
            if (groundID == 0) continue;                                   // no ground

            /* 2 ▸ Biome lookup ------------------------------------------------- */
            byte biomeID = chunk.biomeIDs[localX, localY];
            if (biomeID >= data.biomeDatabase.biomelist.Length) continue;

            BiomeData biome = data.biomeDatabase.biomelist[biomeID];
            if (biome == null ||
                biome.foliageTiles == null ||
                biome.foliageTiles.Length == 0) continue;

            /* 3 ▸ Spawn-chance gate ------------------------------------------- */
            if (UnityEngine.Random.value > biome.foliageSpawnChance) continue;

            /* 4 ▸ Overhead cell must be Sky-Air or Underground-Air ------------- */
            int aboveY = localY + 1;
            if (aboveY >= chunkSize) continue;                               // top edge

            int worldXAbove = chunk.position.x * chunk.size + localX;
            int worldYAbove = chunk.position.y * chunk.size + aboveY;
            int aboveID     = world.GetTileID(worldXAbove, worldYAbove);

            if (aboveID != skyID && aboveID != caveID) continue;             // not valid air

            /* 5 ▸ Pick a foliage candidate ------------------------------------ */
            TileData foliageTD = biome.foliageTiles[
                UnityEngine.Random.Range(0, biome.foliageTiles.Length)];
            if (foliageTD == null) continue;

            /* 6 ▸ Ground-compatibility whitelist ------------------------------ */
            if (foliageTD.canPlaceOnTiles != null && foliageTD.canPlaceOnTiles.Count > 0)
            {
                bool allowed = false;
                foreach (var allowedGround in foliageTD.canPlaceOnTiles)
                    if (allowedGround != null && allowedGround.tileID == groundID)
                    {
                        allowed = true;
                        break;
                    }
                if (!allowed) continue;                                      // unsuitable ground
            }

            /* 7 ▸ Place foliage ----------------------------------------------- */
            world.SetTileID(worldXAbove, worldYAbove, foliageTD.tileID);
        }
    }
}


    /// <summary>
    /// Moves a continuous column of powder tiles downward if there's empty space below.
    /// </summary>
    static void SettlePowderColumn(World world, WorldData data, int startX, int startY)
    {
        int startTileID = world.GetTileID(startX, startY);
        if (startTileID < 0) 
            return;

        TileData startTileData = data.tileDatabase.GetTileDataByID(startTileID);
        if (startTileData == null || startTileData.behavior != BlockBehavior.Powder) 
            return;

        // Find the top of this powder stack
        int topY = startY;
        while (IsPowder(world, data, startX, topY + 1))
        {
            topY++;
        }

        int stackHeight = (topY - startY) + 1;

        // Find how far down we can move it
        int bottomY = startY;
        int freeSpace = 0;
        while (IsAirOrLiquid(world, data, startX, bottomY - 1))
        {
            bottomY--;
            freeSpace++;
        }

        if (freeSpace == 0) 
            return;

        // "Drop" the entire stack by 'freeSpace'
        int distance = freeSpace;
        for (int y = startY; y <= topY; y++)
        {
            int oldTileID = world.GetTileID( startX, y);
            if (oldTileID <= 0) 
                continue;

            // Move the powder downward
            world.SetTileID( startX, y - distance, oldTileID);
            // Replace the old spot with air
            world.SetTileID(startX, y, data.tileDatabase.UndergroundAirTile.tileID);
        }
    }

    static bool IsPowder(World world, WorldData data, int x, int y)
    {
        int id = world.GetTileID( x, y);
        if (id <= 0) return false;

        TileData td = data.tileDatabase.GetTileDataByID(id);
        return (td != null && td.behavior == BlockBehavior.Powder);
    }

    static bool IsAirOrLiquid(World world, WorldData data, int x, int y)
    {
        int id = world.GetTileID( x, y);
        if (id < 0) return false;

        TileData td = data.tileDatabase.GetTileDataByID(id);
        if (td == null) return false;

        return (td.behavior == BlockBehavior.Air || td.behavior == BlockBehavior.Liquid);
    }

    /// <summary>
    /// Checks if the tile at localX, localY is liquid, and if so, calls SpreadLiquidGlobal.
    /// </summary>
    static void CheckAndSpreadLiquid(World world, Chunk chunk, WorldData data, int localX, int localY)
    {
        int worldX = chunk.position.x * chunk.size + localX;
        int worldY = chunk.position.y * chunk.size + localY;
        int tileID = world.GetTileID(worldX, worldY);
        if (tileID <= 0) return;

        TileData tileData = data.tileDatabase.GetTileDataByID(tileID);
        if (tileData == null || tileData.behavior != BlockBehavior.Liquid) 
            return;

        SpreadLiquidGlobal(world, data, worldX, worldY);
    }

  /// <summary>
/// Spreads liquid from (startX, startY) by flood-fill, overwriting air/vine with liquid.
/// Now also sets ChunkFlags.Liquids on any chunk that receives liquid.
/// </summary>
static void SpreadLiquidGlobal(World world, WorldData data, int startX, int startY)
{
    int startTileID = world.GetTileID( startX, startY);
    if (startTileID < 0) return;

    TileData tileData = data.tileDatabase.GetTileDataByID(startTileID);
    if (tileData == null || tileData.behavior != BlockBehavior.Liquid) 
        return;

    var queue = new Queue<Vector2Int>();
    var visited = new HashSet<Vector2Int>();
    var startPos = new Vector2Int(startX, startY);

    queue.Enqueue(startPos);
    visited.Add(startPos);

    // We only spread downward, left, right for this demonstration
    Vector2Int[] neighbors = new Vector2Int[]
    {
        new Vector2Int(0, -1),
        new Vector2Int(-1, 0),
        new Vector2Int(1, 0),
    };

    while (queue.Count > 0)
    {
        var current = queue.Dequeue();
        int cx = current.x;
        int cy = current.y;

        foreach (var dir in neighbors)
        {
            int nx = cx + dir.x;
            int ny = cy + dir.y;
            var nPos = new Vector2Int(nx, ny);

            if (visited.Contains(nPos)) 
                continue;

            int neighborTileID = world.GetTileID( nx, ny);
            if (neighborTileID < 0)
            {
                visited.Add(nPos);
                continue;
            }

            TileData neighborData = data.tileDatabase.GetTileDataByID(neighborTileID);

            // Liquid can spread into air or vine
            if (neighborData == null 
                || neighborData.behavior == BlockBehavior.Air 
                || neighborData.behavior == BlockBehavior.Vine)
            {
                // Overwrite with the same liquid tile ID
                world.SetTileID(nx, ny, startTileID);

                // NEW: Mark the chunk as having liquids
                // Find which chunk this tile belongs to
                int chunkX = nx / world.Data.chunkSize;
                int chunkY = ny / world.Data.chunkSize;
                Chunk targetChunk = world.GetChunk(new Vector2Int(chunkX, chunkY));
                if (targetChunk != null)
                {
                    // Add the liquids flag
                    targetChunk.AddFlags(ChunkFlags.Liquids);
                }

                queue.Enqueue(nPos);
            }
            visited.Add(nPos);
        }
    }
}


    /// <summary>
    /// Attempts to grow vines downward from a tile with a given chance, if biome allows it.
    /// </summary>
    static void CheckAndGrowVines(World world, Chunk chunk, WorldData data, int localX, int localY)
    {
        int frontTileID = chunk.frontLayerTileIndexes[localX, localY];
        if (frontTileID <= 0) return;

        // If your chunk still has an old "biomeIDs" array for each tile, you can read it:
        byte biomeID = chunk.biomeIDs[localX, localY];
        if (biomeID >= data.biomeDatabase.biomelist.Length) 
            return;

        BiomeData biome = data.biomeDatabase.biomelist[biomeID];
        if (biome == null) 
            return;

        if (biome.vineChance <= 0f) 
            return;

        float roll = UnityEngine.Random.value;
        if (roll > biome.vineChance) 
            return;

        TileData baseTile = data.tileDatabase.GetTileDataByID(frontTileID);
        if (baseTile == null || baseTile.vineTile == null)
            return;

        int vineLength = UnityEngine.Random.Range(baseTile.vineMinLength, baseTile.vineMaxLength + 1);
        if (vineLength <= 0) 
            return;

        int worldX = chunk.position.x * chunk.size + localX;
        int worldY = chunk.position.y * chunk.size + localY;
        int nextY = worldY - 1;

        for (int i = 0; i < vineLength; i++)
        {
            if (nextY < 0) 
                break;

            int belowTileID = world.GetTileID( worldX, nextY);
            if (belowTileID < 0) 
                break;

            TileData belowTileData = data.tileDatabase.GetTileDataByID(belowTileID);
            bool isAir = (belowTileData == null || belowTileData.behavior == BlockBehavior.Air);
            if (isAir)
            {
                world.SetTileID(worldX, nextY, baseTile.vineTile.tileID);
            }
            else
            {
                break;
            }
            nextY--;
        }
    }

    /// <summary>
    /// Checks if a biome supports saplings, and if so, tries to place them on top of valid ground tiles.
    /// </summary>
  /// <summary>
/// Instead of dropping a sapling, pick a random BlueprintTree from the
/// biome and try to plant it directly if there's room.
/// </summary>
/// <summary>
/// Picks a random BlueprintTree for each ground tile and plants it
/// only when
///   • the biome allows trees,
///   • RNG ≤ treeSpawnChance,
///   • there is air above the ground, **and**
///   • the ground tile is in the prefab’s SuitableGroundTiles list
///     (unless the list is empty, which means “anything goes”).
/// The prefab’s own HasFreeSpace check still runs inside PlaceStructure,
/// so you remain protected against ceilings and neighbouring objects.
/// </summary>
static void CheckAndPlantTrees(World world, Chunk chunk, WorldData data)
{
    int chunkSize = chunk.size;

    for (int localY = 0; localY < chunkSize; localY++)
    {
        for (int localX = 0; localX < chunkSize; localX++)
        {
            /* 1 ▸ Ground-tile & biome lookup */
            int groundID = chunk.frontLayerTileIndexes[localX, localY];
            if (groundID <= 0) continue;

            byte biomeID = chunk.biomeIDs[localX, localY];
            if (biomeID >= data.biomeDatabase.biomelist.Length) continue;

            BiomeData biome = data.biomeDatabase.biomelist[biomeID];
            if (biome == null || biome.Trees == null || biome.Trees.Length == 0) continue;

            /* 2 ▸ Probability gate */
            if (UnityEngine.Random.value > biome.treeSpawnChance) continue;

            /* 3 ▸ Must have air directly above */
            int aboveY = localY + 1;
            if (aboveY >= chunkSize) continue;                            // top-edge
            if (chunk.frontLayerTileIndexes[localX, aboveY] != 0) continue;

            /* 4 ▸ Pick a prefab that allows this ground tile */
            BlueprintTree treeBP = null;
            const int maxAttempts = 4;                                    // avoid infinite loops
            for (int attempt = 0; attempt < maxAttempts; attempt++)
            {
                var candidate = biome.Trees[UnityEngine.Random.Range(0, biome.Trees.Length)];
                if (candidate == null) continue;

                // Accept immediately when the whitelist is empty
                if (candidate.SuitableGroundTiles == null || candidate.SuitableGroundTiles.Length == 0)
                {
                    treeBP = candidate;
                    break;
                }

                // Otherwise the ground must match one entry in the whitelist
                foreach (var allowed in candidate.SuitableGroundTiles)
                    if (allowed != null && allowed.tileID == groundID)
                    {
                        treeBP = candidate;
                        break;
                    }

                if (treeBP != null) break;                               // found a match
            }

            if (treeBP == null) continue;                                 // no prefab fit this ground

            /* 5 ▸ Convert local → world and plant */
            int worldX = chunk.position.x * chunk.size + localX;
            int worldY = chunk.position.y * chunk.size + localY;          // surface
            int anchorY = worldY + 1;                                     // first trunk tile

            treeBP.PlaceStructure(world, worldX, anchorY);                // HasFreeSpace inside
        }
    }
}



    /// <summary>
    /// Grows newly placed saplings into mature forms if there's enough overhead space.
    /// </summary>
static void GrowNewlyPlacedSaplings(
    World world,
    Chunk chunk,
    WorldData data,
    List<Vector2Int> newlyPlacedSaplings)
{
    foreach (var localPos in newlyPlacedSaplings)
    {
        int lx = localPos.x;
        int ly = localPos.y;

        int tileID = chunk.frontLayerTileIndexes[lx, ly];
        if (tileID <= 0) continue;

        TileData saplingTD = data.tileDatabase.GetTileDataByID(tileID);
        if (saplingTD == null)                    continue;
        if (saplingTD.BlueprintGrowableMatured == null) continue;

        var matureBP = saplingTD.BlueprintGrowableMatured;

        // Convert local to world coords once
        int wx = chunk.position.x * chunk.size + lx;
        int wy = chunk.position.y * chunk.size + ly;

      

        matureBP.PlaceStructure(world, wx, wy);
    }
}

   


}
.
------------------------------
File: C:\Users\komja_5iitwgq\Documents\UnityProjects\unity games\Anywhere\Assets\Scripts\World\WorldTilemapViewer.cs
------------------------------
/*  WorldTilemapViewer.cs – MULTI-TARGET, CHUNK-BASED RENDERING
 *  --------------------------------------------------------------------
 *  • Autocreates Grid + Front / Back Tilemaps if they are missing.
 *  • Tracks any number of Transforms, each with its own **chunk** view-radius.
 *  • Renders complete chunks that intersect at least one target’s range.
 *  • Re-renders only when the visible-chunk set changes → fast on huge worlds.
 *  • AlignToWorld(world) positions the Grid so (0,0) = bottom-left of the map.
 *--------------------------------------------------------------------*/

using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;

[RequireComponent(typeof(Grid))]
public class WorldTilemapViewer : MonoBehaviour
{
    /* ───────────────────────── Inspector refs ───────────────────────── */
    [Header("World ref (auto-found if blank)")]
    public WorldManager worldManager;             // wired by GameManager

    [Header("Tilemaps (auto-create if null)")]
    public Tilemap frontMap;
    public Tilemap backMap;

    [Header("Display options")]
    public bool showBackground    = true;
    public bool clearBeforeRender = true;

    /* ───────────────────────── Target definition ────────────────────── */
    [System.Serializable]
    public class TrackedTarget
    {
        public Transform target;
        [Min(0)] public int chunkRadius = 4;      // Manhattan radius in **chunks**
    }

    [Header("Tracked Targets")]
    public List<TrackedTarget> targets = new();

    public void AddTarget(Transform t, int radiusChunks = 4)
    {
        if (!t) return;
        targets.Add(new TrackedTarget
        {
            target      = t,
            chunkRadius = Mathf.Max(0, radiusChunks)
        });
    }
    public void RemoveTarget(Transform t) => targets.RemoveAll(tt => tt.target == t);

    /* ───────────────────────── Internals ────────────────────────────── */
    readonly Dictionary<int, TileBase> tileBaseByID = new();
    HashSet<Vector2Int> lastVisibleChunks = new();

    /* ===================================================================
     *  INITIALISATION
     * =================================================================*/
    void Awake()
    {
        _ = GetComponent<Grid>();                            // make sure Grid exists

        if (frontMap == null)
        {
            var fg = new GameObject("FrontMap");
            fg.transform.SetParent(transform, false);
            frontMap = fg.AddComponent<Tilemap>();
            fg.AddComponent<TilemapRenderer>();
        }
        if (backMap == null)
        {
            var bg = new GameObject("BackMap");
            bg.transform.SetParent(transform, false);
            backMap = bg.AddComponent<Tilemap>();
            var br  = bg.AddComponent<TilemapRenderer>();
            br.sortingOrder = -10;                           // draw behind the front
        }

        if (worldManager == null)
            worldManager = FindObjectOfType<WorldManager>();
    }

    /* ===================================================================
     *  PUBLIC: align Grid so (0,0) sits at bottom-left of the world
     * =================================================================*/
    public void AlignToWorld(World world)
    {
        if (world == null) return;

        float ox = -world.widthInChunks  * world.chunkSize * 0.5f;
        float oy = -world.heightInChunks * world.chunkSize * 0.5f;
        transform.position = new Vector3(ox, oy, 0f);
    }

    /* ===================================================================
     *  FRAME UPDATE – build visible-chunk set, redraw if it changed
     * =================================================================*/
    void LateUpdate()
    {
        World world = worldManager ? worldManager.GetCurrentWorld() : null;
        if (world == null) return;

        int cs = world.chunkSize;                            // chunk size in tiles
        var newSet = new HashSet<Vector2Int>();

        foreach (var tt in targets)
        {
            if (tt?.target == null) continue;

            Vector3   pos   = tt.target.position;
            int       cx0   = Mathf.FloorToInt(pos.x / cs);
            int       cy0   = Mathf.FloorToInt(pos.y / cs);
            int       cr    = tt.chunkRadius;

            for (int cy = cy0 - cr; cy <= cy0 + cr; cy++)
            for (int cx = cx0 - cr; cx <= cx0 + cr; cx++)
            {
                if (Mathf.Abs(cx - cx0) + Mathf.Abs(cy - cy0) > cr) continue; // Manhattan
                if (cx < 0 || cy < 0 || cx >= world.widthInChunks || cy >= world.heightInChunks)
                    continue;
                newSet.Add(new Vector2Int(cx, cy));
            }
        }

        if (!newSet.SetEquals(lastVisibleChunks))
        {
            lastVisibleChunks = newSet;
            RenderChunks(world, newSet);
        }
    }

    /* ===================================================================
     *  CHUNK-BASED RENDERER
     * =================================================================*/
    void RenderChunks(World world, HashSet<Vector2Int> chunkSet)
    {
        if (clearBeforeRender)
        {
            frontMap.ClearAllTiles();
            if (backMap) backMap.ClearAllTiles();
        }

        TileDatabase db = world.tiles;
        if (db == null) return;

        int cs = world.chunkSize;

        foreach (var coord in chunkSet)
        {
            Chunk chunk = world.GetChunk(coord);
            if (chunk == null) continue;

            int wx0 = coord.x * cs;
            int wy0 = coord.y * cs;

            for (int ly = 0; ly < cs; ly++)
            for (int lx = 0; lx < cs; lx++)
            {
                int id = chunk.frontLayerTileIndexes[lx, ly];
                if (id > 0)
                    frontMap.SetTile(new Vector3Int(wx0 + lx, wy0 + ly, 0), GetTileBase(db, id));

                if (showBackground && backMap)
                {
                    int bid = chunk.backgroundLayerTileIndexes[lx, ly];
                    if (bid > 0)
                        backMap.SetTile(new Vector3Int(wx0 + lx, wy0 + ly, 0), GetTileBase(db, bid));
                }
            }
        }

        frontMap.RefreshAllTiles();
        if (backMap) backMap.RefreshAllTiles();
    }

    /* ------------------------------------------------------------------*/
    TileBase GetTileBase(TileDatabase db, int id)
    {
        if (tileBaseByID.TryGetValue(id, out var tb)) return tb;
        TileData td = db.GetTileDataByID(id);
        tb = td ? td.tileBase : null;
        tileBaseByID[id] = tb;
        return tb;
    }
}
.
